import { isPrimitive } from '../utils/isPrimitive.js'

export function generateNewReference(type) {
    function getRandomNumberString(digits) {
        const min = Math.pow(10, digits - 1)
        const number = Math.trunc(Math.random() * 9 * min) + min
        return number.toString()
    }

    const part1 = getRandomNumberString(8)
    const part2 = getRandomNumberString(8)

    return `flow-rv-${type}-id-${part1}-${part2}`
}

const runComputedDependencesExtractor = (callback, variableReference, configuration) => {
    $FlowEngine.computedDependencyExtractorRunning = true
    $FlowEngine.currentReactiveVariableReference = variableReference

    callback()

    configuration.dependsOn.push(Array.from($FlowEngine.extractedComputedDependencies))

    $FlowEngine.computedDependencyExtractorRunning = false
    $FlowEngine.currentReactiveVariableReference = ''
    $FlowEngine.extractedComputedDependencies = new Set()
}

const getReactiveVariableType = (configuration) => {
    let type = ''

    if (configuration.isRef) {
        type = 'ref'
    } else if (configuration.isComputed) {
        type = 'computed'
    } else if (configuration.isProp) {
        type = 'prop'
    } else {
        type = 'unspecified'
    }

    return type
}

const isValueAnActualObject = (value) => {
    return value !== null && Object.prototype.toString.call(value) === '[object Object]';
};

const getReactiveVariable = (value, configuration) => {
    if (!isValueAnActualObject(value)) return value

    const outputReactiveObject = {};

    for (const key in value) {
        const condition = isValueAnActualObject(value[key])

        outputReactiveObject[key] = condition ? reactiveVariable(value[key], configuration) : value[key];
    }

    return outputReactiveObject;
};

const lockedProxyProperties = ['value', 'configuration', 'variableReference']

export const reactiveVariable = (value, configuration = {}) => {
    configuration.isReactiveVariable = true

    let type = getReactiveVariableType(configuration)

    const variableReference = generateNewReference(type)

    $FlowEngine.watchCallbacks[variableReference] ??= []

    if (configuration.isComputed) {
        runComputedDependencesExtractor(value, variableReference, configuration)
    }

    configuration.isValueAnActualObject = isValueAnActualObject(value)
    configuration.isValuePrimitive = isPrimitive(value)

    const variableProxy = new Proxy(
        {
            value: getReactiveVariable(value, configuration),
            configuration,
            variableReference
        },
        {
            get(target, property) {
                if ($FlowEngine.computedDependencyExtractorRunning) {
                    $FlowEngine.extractedComputedDependencies.add(variableReference)
                    target.configuration.influences.push($FlowEngine.currentReactiveVariableReference)

                    return
                }

                if ($FlowEngine.dependencyExtractorRunning) {
                    $FlowEngine.extractedDependencies.add(variableReference)
                }

                if (!lockedProxyProperties.includes(property)) {
                    return target.value[property]
                }

                const propertyValue = target[property]

                return typeof propertyValue === 'function' ? propertyValue() : propertyValue
            },

            set(target, property, newValue) {
                const previousValue = target[property]

                if (configuration.isValuePrimitive && newValue === previousValue) {
                    return true
                }

                if (!lockedProxyProperties.includes(property)) {
                    target.value[property] = newValue
                }

                target[property] = newValue

                const watchCallbacks = $FlowEngine.watchCallbacks[variableReference]

                if (watchCallbacks.length > 0) {
                    watchCallbacks.forEach(watchSignal => watchSignal(newValue, previousValue))
                }

                const influencedReferences = target.configuration.influences

                influencedReferences.forEach((influencedReference) => {
                    const computedWatchCallbacks = $FlowEngine.watchCallbacks[influencedReference]

                    const reactiveComputedReference = $FlowEngine.reactiveVariables[influencedReference]

                    computedWatchCallbacks.forEach(watchSignal => watchSignal(reactiveComputedReference.value, reactiveComputedReference.value))
                })

                $FlowEngine.runReactiveEffects({ reference: variableReference, configuration })

                return true
            }
        }
    )

    $FlowEngine.reactiveVariables[variableReference] = variableProxy

    return variableProxy
}