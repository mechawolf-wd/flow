import { isPrimitive } from '../utils/isPrimitive.js'

export function generateNewReference(type) {
    return `flow-rv-${type}-id-${String(Math.trunc(Math.random() * 100000000)).padEnd(12, '0')}-${String(Math.trunc(Math.random() * 100000000)).padEnd(12, '0')}`
}

export const createReactiveArray = (array, reference) => {
    return new Proxy(array, {
        get(target, property, receiver) {
            const propertyOrFunctionAccessed = Reflect.get(target, property, receiver);

            if (typeof propertyOrFunctionAccessed === 'function') {
                return function (...methodArguments) {
                    if (property === 'push' || property === 'unshift' || property === 'pop' || property === 'shift') {
                        requestAnimationFrame(() => {
                            $FlowEngine.runReactiveEffects({ reference })
                        })
                    }

                    return propertyOrFunctionAccessed.apply(this, methodArguments);
                };
            }

            return propertyOrFunctionAccessed;
        },
        set(target, property, value, receiver) {
            return Reflect.set(target, property, value, receiver);
        },
        deleteProperty(target, property) {
            return Reflect.deleteProperty(target, property);
        }
    });
}

const runComputedDependencesExtractor = (callback, variableReference, configuration) => {
    $FlowEngine.computedDependencyExtractorRunning = true
    $FlowEngine.currentReactiveVariableReference = variableReference

    callback()

    configuration.dependsOn.push(Array.from($FlowEngine.extractedDependencies))

    $FlowEngine.computedDependencyExtractorRunning = false
    $FlowEngine.currentReactiveVariableReference = ''
    $FlowEngine.extractedDependencies = new Set()
}

const getReactiveVariableType = (configuration) => {
    let type = ''

    if (configuration.isRef) {
        type = 'ref'
    } else if (configuration.isComputed) {
        type = 'computed'
    } else if (configuration.isProp) {
        type = 'prop'
    } else {
        type = 'unspecified'
    }

    return type
}

export const reactiveVariable = (value, configuration = {}) => {
    configuration.isReactiveVariable = true

    let type = getReactiveVariableType(configuration)

    const variableReference = generateNewReference(type)

    $FlowEngine.watchCallbacks[variableReference] ??= []

    if (configuration.isComputed) {
        runComputedDependencesExtractor(value, variableReference, configuration)
    }

    const isValuePrimitive = isPrimitive(value)

    const variableProxy = new Proxy({ value, configuration, variableReference }, {
        get(target, property) {
            if ($FlowEngine.computedDependencyExtractorRunning) {
                $FlowEngine.extractedDependencies.add(variableReference)
                target.configuration.influences.push($FlowEngine.currentReactiveVariableReference)

                return
            }

            if ($FlowEngine.expressionDependencyExtractorRunning) {
                $FlowEngine.extractedExpressionDependencies.add(variableReference)
            }

            const propertyValue = target[property]

            return typeof propertyValue === 'function' ? propertyValue() : propertyValue
        },
        set(target, property, newValue) {
            const oldValue = target[property]

            if (isValuePrimitive && newValue === oldValue) {
                return true
            }

            target[property] = newValue

            if ($FlowEngine.watchCallbacks[variableReference].length > 0) {
                $FlowEngine.watchCallbacks[variableReference].forEach(watchSignal => watchSignal(newValue, oldValue))
            }

            $FlowEngine.runReactiveEffects({ reference: variableReference, configuration })

            return true
        }
    })

    $FlowEngine.reactiveVariables[variableReference] = variableProxy

    return variableProxy
}