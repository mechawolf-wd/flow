export function generateNewReference(type) {
    return `flow-rv-${type}-id-${String(Math.trunc(Math.random() * 100000000)).padEnd(12, '0')}-${String(Math.trunc(Math.random() * 100000000)).padEnd(12, '0')}`
}

export const createReactiveArray = (array, reference) => {
    return new Proxy(array, {
        get(target, property, receiver) {
            const propertyOrFunctionAccessed = Reflect.get(target, property, receiver);

            if (typeof propertyOrFunctionAccessed === 'function') {
                return function (...methodArguments) {
                    if (property === 'push' || property === 'unshift' || property === 'pop' || property === 'shift') {
                        requestAnimationFrame(() => {
                            $Flow.runEffects({ reference })
                        })
                    }

                    return propertyOrFunctionAccessed.apply(this, methodArguments);
                };
            }

            return propertyOrFunctionAccessed;
        },
        set(target, property, value, receiver) {
            return Reflect.set(target, property, value, receiver);
        },
        deleteProperty(target, property) {
            return Reflect.deleteProperty(target, property);
        }
    });
}

const queueReferenceExtracting = (computedCallback, variableReference, configuration) => {
    $Flow.computedDependencyExtractorRunning = true
    $Flow.currentSignalReference = variableReference

    computedCallback()

    configuration.dependsOn.push(Array.from($Flow.extractedDependencies))

    $Flow.currentSignalReference = ''
    $Flow.extractedDependencies = new Set()
    $Flow.computedDependencyExtractorRunning = false
}

export const reactiveVariable = (value, configuration = {}) => {
    configuration.isReactiveVariable = true

    let type = ''

    if (configuration.isRef) {
        type = 'ref'
    } else if (configuration.isComputed) {
        type = 'computed'
    } else {
        type = 'unspecified'
    }

    const variableReference = generateNewReference(type)

    $Flow.watchCallbacks[variableReference] ??= []

    if (configuration.isComputed) {
        queueReferenceExtracting(value, variableReference, configuration)
    }

    const variableProxy = new Proxy({ value, configuration, variableReference }, {
        get(target, property) {
            const value = target[property]

            if ($Flow.computedDependencyExtractorRunning) {
                $Flow.extractedDependencies.add(variableReference)
                target.configuration.influences.push($Flow.currentSignalReference)

                return
            }

            // TODO: Reference for the computed's oldValue does not work here, investigate how to do it.
            if (typeof value === 'function') {
                const newComputedValue = value()

                $Flow.watchCallbacks[variableReference].forEach(watchSignal => watchSignal(newComputedValue, newComputedValue))
            }

            return value
        },
        set(target, property, newValue) {
            // ---- Assigning the previous value of the variable to a new variable. ----
            const oldValue = target[property]

            // ---- Setting the new value. ----
            target[property] = newValue

            // ---- Calling watchers associated with the variable referenced. ----
            $Flow.watchCallbacks[variableReference].forEach(watchSignal => watchSignal(newValue, oldValue))

            // ---- Running effects that have this as a dependency, eg. attributes or text contents. ----
            $Flow.runEffects({ reference: variableReference, configuration })

            return true
        }
    })

    $Flow.reactiveVariableDictionary[variableReference] = variableProxy

    return variableProxy
}