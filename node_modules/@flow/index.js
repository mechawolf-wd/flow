import { templateCompiler } from "./src/compiler/templateCompiler.js"
import { showErrorOverlay } from "./utils/showErrorOverlay.js"
// import { showLoadingOverlay } from "./utils/showLoadingOverlay.js"
import { generateStore } from "../@flow/store/generateStore.js"

const DEFAULT_ENTRY_POINT_COMPONENT_NAME = "APP"
const DEFAULT_ENTRY_POINT_ELEMENT_ID = "#app"

const callWithErrorOverlay = (callback) => {
    try {
        callback()
    } catch (error) {
        showErrorOverlay(error)
    }
}

export const Flow = {
    render() {
        $FlowEngine.storeGenerationFunctions.forEach(storeGenerationFunction => storeGenerationFunction())

        callWithErrorOverlay(() => {
            const defaultEntryPointComponentFunction = $FlowEngine.componentModules[DEFAULT_ENTRY_POINT_COMPONENT_NAME].componentFunction

            templateCompiler(
                defaultEntryPointComponentFunction,
                document.body,
                DEFAULT_ENTRY_POINT_ELEMENT_ID,
                undefined
            )
        })
    },
    defineComponents(componentModules) {
        componentModules.forEach((componentModule) => {
            $FlowEngine.defineComponentModule(componentModule)
        })
    },
    defineStores(stores) {
        stores.forEach((storeFunction) => {
            $FlowEngine.defineStore(storeFunction)
        })
    },
}

window.$FlowEngine = (() => {
    const reactiveEffects = []
    const lastInfluencedVariableReference = ""

    const reactiveVariables = {}
    const watchCallbacks = {}
    const stores = []
    const storeGenerationFunctions = []

    const propertiesByComponent = {}
    const eventsByComponent = {}
    const templateByComponent = {}
    const styleByComponent = {}

    const componentModules = {}

    const computedDependencyExtractorRunning = false
    const extractedDependencies = new Set()
    const currentReactiveVariableReference = ""

    const expressionDependencyExtractorRunning = false
    const extractedExpressionDependencies = new Set()

    // Effects
    const queueReactiveEffect = (newReactiveEffect, configuration = { runOnQueue: true }) => {
        $FlowEngine.expressionDependencyExtractorRunning = true

        if (configuration.runOnQueue === undefined || configuration.runOnQueue) {
            newReactiveEffect.effect()
        }

        if ($FlowEngine.extractedExpressionDependencies.size > 0) {
            const extractedExpressionDependencies = Array.from($FlowEngine.extractedExpressionDependencies)

            if (extractedExpressionDependencies.length > 0) {
                newReactiveEffect.references = extractedExpressionDependencies

                reactiveEffects.push(newReactiveEffect)
            }

            $FlowEngine.extractedExpressionDependencies = new Set()
        }

        $FlowEngine.expressionDependencyExtractorRunning = false
    }

    const runReactiveEffects = ({
        reference: reactiveVariableReference,
        configuration = {},
    }) => {
        if ($FlowEngine.lastInfluencedEffectReference === reactiveVariableReference) return

        $FlowEngine.lastInfluencedEffectReference = reactiveVariableReference

        reactiveEffects.forEach(({ references: reactiveEffectReferences, effect: reactiveEffect }) => {
            reactiveEffectReferences.forEach((effectReference) => {
                if (effectReference === reactiveVariableReference) {
                    reactiveEffect()

                    configuration.influences.forEach((influencedReference) => {
                        const influencedReferenceConfiguration = $FlowEngine.reactiveVariables[influencedReference]?.configuration || {}

                        runReactiveEffects({
                            reference: influencedReference,
                            configuration: influencedReferenceConfiguration,
                        })
                    })
                }
            })
        }
        )

        $FlowEngine.lastInfluencedEffectReference = ""
    }

    const defineComponentModule = (componentModule) => {
        // TODO: This 'find' instruction is not checking whether the found 'function' is a component.
        const componentFunction = Object.values(componentModule).find(
            (value) => typeof value === "function"
        )

        const upperCaseComponentName = componentFunction.name.toUpperCase()

        $FlowEngine.templateByComponent[upperCaseComponentName] =
            componentModule["template"] || []
        $FlowEngine.styleByComponent[upperCaseComponentName] =
            componentModule["style"] || []
        $FlowEngine.propertiesByComponent[upperCaseComponentName] =
            componentModule["props"] || []
        $FlowEngine.eventsByComponent[upperCaseComponentName] =
            componentModule["emits"] || []

        componentModules[upperCaseComponentName] = { componentFunction }
    }

    const setStoreDefinition = (name, store) => {
        stores.push({
            name,
            store,
        })
    }

    const useStore = (storeName) => {
        const storeDefinition = stores.find((store) => {
            return store.name === storeName
        })

        return storeDefinition.store
    }

    const defineStore = (storeFunction) => {
        const storeName = storeFunction.name

        const storeGenerationFunction = generateStore(storeName, storeFunction)

        storeGenerationFunctions.push(storeGenerationFunction)
    }

    return {
        effects: reactiveEffects,
        lastInfluencedEffectReference: lastInfluencedVariableReference,

        reactiveVariables,
        watchCallbacks,
        stores,
        storeGenerationFunctions,

        propertiesByComponent,
        eventsByComponent,
        templateByComponent,
        styleByComponent,

        componentModules,

        computedDependencyExtractorRunning,
        extractedDependencies,
        currentReactiveVariableReference,

        expressionDependencyExtractorRunning,
        extractedExpressionDependencies,

        runReactiveEffects,
        queueReactiveEffect,
        defineComponentModule,
        setStoreDefinition,
        useStore,
        defineStore
    }
})()

const routerStore = ({ ref }) => {
    const path = ref("/")

    return {
        path
    }
}

const useRouterStore = generateStore("routerStore", routerStore)
$FlowEngine.storeGenerationFunctions.push(useRouterStore)
