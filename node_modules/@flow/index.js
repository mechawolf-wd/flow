import { templateCompiler } from "./src/templateCompiler.js";
import { showErrorOverlay } from "./utils/showErrorOverlay.js";
// import { showLoadingOverlay } from "./utils/showLoadingOverlay.js";
import { generateStore } from "../@flow/store/generateStore.js";

const DEFAULT_ENTRY_POINT_COMPONENT_NAME = "APP";
const DEFAULT_ENTRY_POINT_ELEMENT_ID = "#app";

const callWithErrorOverlay = (callback) => {
    try {
        callback();
    } catch (error) {
        showErrorOverlay(error);
    }
};

export const Flow = {
    render() {
        callWithErrorOverlay(() => {
            const defaultEntryPointComponentFunction =
                $FlowEngine.componentModules[DEFAULT_ENTRY_POINT_COMPONENT_NAME]
                    .componentFunction;

            templateCompiler(
                defaultEntryPointComponentFunction,
                document.body,
                DEFAULT_ENTRY_POINT_ELEMENT_ID,
                undefined
            );
        });
    },
    defineComponents(componentModules) {
        componentModules.forEach((componentModule) => {
            $FlowEngine.defineComponentModule(componentModule);
        });
    },
    defineStores(stores) {
        stores.forEach((storeFunction) => {
            $FlowEngine.defineStore(storeFunction);
        });
    },
};

window.$FlowEngine = (() => {
    const reactiveEffects = [];
    const lastInfluencedVariableReference = "";

    const reactiveVariables = {};
    const watchCallbacks = {};
    const stores = [];

    const propertiesByComponent = {};
    const eventsByComponent = {};

    const componentModules = {};

    const computedDependencyExtractorRunning = false;
    const extractedDependencies = new Set();
    const currentReactiveVariableReference = "";

    const expressionDependencyExtractorRunning = false;
    const extractedExpressionDependencies = new Set();

    // Effects
    const queueEffect = (newReactiveEffect) => {
        $FlowEngine.expressionDependencyExtractorRunning = true;

        newReactiveEffect.effect();

        if ($FlowEngine.extractedExpressionDependencies.size > 0) {
            const extractedExpressionDependencies = Array.from($FlowEngine.extractedExpressionDependencies);

            if (extractedExpressionDependencies.length > 0) {
                newReactiveEffect.references = extractedExpressionDependencies;

                reactiveEffects.push(newReactiveEffect);
            }

            $FlowEngine.extractedExpressionDependencies = new Set();
        }

        $FlowEngine.expressionDependencyExtractorRunning = false;
    };

    const runReactiveEffects = ({
        reference: reactiveVariableReference,
        configuration = {},
    }) => {
        if ($FlowEngine.lastInfluencedEffectReference === reactiveVariableReference) return;

        $FlowEngine.lastInfluencedEffectReference = reactiveVariableReference;

        if (configuration.isComputed && $FlowEngine.watchCallbacks[reactiveVariableReference].length > 0) {
            const newComputedValue = $FlowEngine.reactiveVariables[reactiveVariableReference].value;

            // TODO: This instruction needs to be changed since watchSignal gets computed's new value as both arguments.
            $FlowEngine.watchCallbacks[reactiveVariableReference].forEach(
                (watchSignal) => watchSignal(newComputedValue, newComputedValue)
            );
        }

        reactiveEffects.forEach(({ references: reactiveEffectReferences, effect: reactiveEffect }) => {
            reactiveEffectReferences.forEach((effectReference) => {
                if (effectReference === reactiveVariableReference) {
                    reactiveEffect();

                    configuration.influences.forEach((influencedReference) => {
                        const influencedReferenceConfiguration = $FlowEngine.reactiveVariables[influencedReference]?.configuration || {};

                        runReactiveEffects({
                            reference: influencedReference,
                            configuration: influencedReferenceConfiguration,
                        });
                    });
                }
            });
        }
        );

        $FlowEngine.lastInfluencedEffectReference = "";
    };

    const defineComponentModule = (componentModule) => {
        // TODO: This 'find' instruction is not checking whether the found 'function' is a component.
        const componentFunction = Object.values(componentModule).find(
            (value) => typeof value === "function"
        );

        const upperCaseComponentName = componentFunction.name.toUpperCase();

        $FlowEngine.propertiesByComponent[upperCaseComponentName] =
            componentModule["props"] || [];
        $FlowEngine.eventsByComponent[upperCaseComponentName] =
            componentModule["emits"] || [];

        componentModules[upperCaseComponentName] = { componentFunction };
    };

    const setStore = (name, store) => {
        stores.push({
            name,
            store,
        });
    };

    const useStore = (storeName) => {
        const storeDefinition = stores.find((store) => {
            return store.name === storeName;
        });

        return storeDefinition.store;
    };

    const defineStore = (storeFunction) => {
        const storeName = storeFunction.name;

        const storeGenerator = generateStore(storeName, storeFunction);

        storeGenerator();
    };

    return {
        effects: reactiveEffects,
        lastInfluencedEffectReference: lastInfluencedVariableReference,

        reactiveVariables,
        watchCallbacks,
        stores,

        propertiesByComponent,
        eventsByComponent,

        componentModules,

        computedDependencyExtractorRunning,
        extractedDependencies,
        currentReactiveVariableReference,

        expressionDependencyExtractorRunning,
        extractedExpressionDependencies,

        runReactiveEffects,
        queueEffect,
        setStore,
        useStore,
        defineStore,
        defineComponentModule,
    };
})();
