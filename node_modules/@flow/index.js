import { templateCompiler } from './src/templateCompiler.js'
import { showErrorOverlay } from './utils/showErrorOverlay.js'

export const Flow = {
    connect(callback) {
        try {
            callback()
        } catch (error) {
            showErrorOverlay(error)
        }
    },
    mountStore(callback) {
        callback()
    },
    mount: templateCompiler
};

window.$Flow = (() => {
    const effects = [];
    const stores = []
    const components = {}
    const watchSignals = {}

    // ------------ EFFECTS ------------
    const queueEffect = (newEffect) => {
        // Immediately calling the effect, eg. replacing innerText or changing attribute value.
        newEffect.effect()

        // Queueing effect so that it can be called in the future once its dependencies change their values.
        effects.push(newEffect)
    }

    const runEffects = ({ reference: variableReference, configuration = {} }) => {
        // Loop through the queued effects.
        effects.forEach(({ references: effectReferences, effect }) => {
            // Calling every effect that has variableReference in its references array.
            effectReferences.forEach((effectReference) => {
                if (effectReference === variableReference && typeof effect === 'function') {
                    // Calling the effect eg. replacing innerText or changing attribute value.
                    effect()

                    // TODO: Implement multiple level - nested computed reloads, Current implementation: single level watching
                    configuration?.influences?.forEach((influencedReference) => {
                        runEffects({ reference: influencedReference })
                    })
                }
            })
        })
    }

    const flushEffects = () => {
        effects.length = []
    }

    // ------------ STORE ------------
    const setStore = (name, store) => {
        stores.push({
            name,
            store
        })
    }

    const useStore = (storeName) => {
        const storeDefinition = stores.find(store => {
            return store.name === storeName
        })

        return storeDefinition.store
    }

    return {
        effects,
        stores,
        components,
        watchSignals,
        runEffects,
        flushEffects,
        queueEffect,
        setStore,
        useStore,
        showErrorOverlay
    }
})()