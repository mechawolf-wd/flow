import { templateCompiler } from './src/templateCompiler.js'
import { showErrorOverlay } from './utils/showErrorOverlay.js'
import { generateStore } from '../@flow/store/generateStore.js'

const DEFAULT_ENTRY_POINT_TAG_NAME = 'App'

export const Flow = {
    render() {
        try {
            const defaultEntryPointComponentFunction = $Flow.components[DEFAULT_ENTRY_POINT_TAG_NAME].componentFunction

            templateCompiler(DEFAULT_ENTRY_POINT_TAG_NAME, defaultEntryPointComponentFunction, document.body)
        } catch (error) {
            showErrorOverlay(error)
        }
    },
};

window.$Flow = (() => {
    const effects = [];
    const stores = []
    const components = {}
    const watchCallbacks = {}

    const computedDependencyExtractorRunning = false
    const extractedDependencies = new Set()
    const currentSignalReference = ''

    const reactiveVariableDictionary = {}

    // ------------ EFFECTS ------------
    const queueEffect = (newEffect) => {
        // Immediately calling the effect, eg. replacing innerText or changing attribute value.
        newEffect.effect()

        // Queueing effect so that it can be called in the future once its dependencies change their values.
        effects.push(newEffect)
    }

    const runEffects = ({ reference: reactiveReference, configuration = {} }) => {
        // Loop through the queued effects.
        effects.forEach(({ references: effectReferences, effect }) => {
            // Calling every effect that has variableReference in its references array.
            effectReferences.forEach((effectReference) => {
                if (effectReference === reactiveReference && typeof effect === 'function') {
                    // Calling the effect eg. replacing innerText or changing attribute value.
                    effect()

                    configuration?.influences?.forEach((influencedReference) => {
                        const influencedReferenceConfiguration = $Flow.reactiveVariableDictionary[influencedReference]?.configuration || {}

                        runEffects({ reference: influencedReference, configuration: influencedReferenceConfiguration })
                    })
                }
            })
        })
    }

    const flushEffects = () => {
        effects.length = []
    }

    // ------------ STORE ------------
    const setStore = (name, store) => {
        stores.push({
            name,
            store
        })
    }

    const useStore = (storeName) => {
        const storeDefinition = stores.find(store => {
            return store.name === storeName
        })

        return storeDefinition.store
    }

    const defineStore = (storeName, storeFunction) => {
        const setupStore = generateStore(storeName, storeFunction)

        setupStore()
    }

    // ------------ COMPONENTS ------------
    const defineComponent = (componentName, componentFunction) => {
        components[componentName] = { componentFunction, metaData: { timesUsed: 0 } }
    }

    return {
        effects,
        stores,
        components,
        watchCallbacks,
        computedDependencyExtractorRunning,
        extractedDependencies,
        currentSignalReference,
        reactiveVariableDictionary,

        runEffects,
        flushEffects,
        queueEffect,
        setStore,
        useStore,
        defineStore,
        defineComponent
    }
})()