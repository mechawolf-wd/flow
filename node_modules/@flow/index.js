import { templateCompiler } from "./src/compiler/templateCompiler.js";
import { showErrorOverlay } from "./utils/showErrorOverlay.js";
// import { showLoadingOverlay } from "./utils/showLoadingOverlay.js"
import { generateStore } from "../@flow/store/generateStore.js";

const DEFAULT_ENTRY_POINT_COMPONENT_NAME = "App";
const DEFAULT_ENTRY_POINT_ELEMENT_ID = "#app";

const callWithErrorOverlay = (callback) => {
    try {
        callback();
    } catch (error) {
        showErrorOverlay(error);
        throw new Error(error);
    }
};

export const Flow = {
    render() {
        $FlowEngine.storeGenerationQueue.forEach(callWithErrorOverlay);

        callWithErrorOverlay(() => {
            const upperCaseEntryPointComponentName =
                DEFAULT_ENTRY_POINT_COMPONENT_NAME.toUpperCase();

            const { componentFunction: defaultEntryPointComponentFunction } =
                $FlowEngine.componentModules[upperCaseEntryPointComponentName];

            templateCompiler(
                defaultEntryPointComponentFunction,
                document.body,
                undefined,
                DEFAULT_ENTRY_POINT_COMPONENT_NAME,
                DEFAULT_ENTRY_POINT_ELEMENT_ID
            );
        });
    },
    defineComponents(componentModules = []) {
        componentModules.forEach((componentModule) => {
            $FlowEngine.defineComponentModule(componentModule);
        });
    },
    defineStores(stores = []) {
        stores.forEach((storeFunction) => {
            $FlowEngine.defineStore(storeFunction);
        });
    },
};

window.$FlowEngine = (() => {
    const reactiveEffects = [];
    const lastInfluencedEffectReference = "";

    const reactiveVariables = {};
    const watchCallbacks = {};
    const stores = {};
    const storeGenerationQueue = [];

    const propertiesByComponent = {};
    const eventsByComponent = {};
    const templateByComponent = {};
    const styleByComponent = {};
    const mountedStyleByComponent = {};

    const componentModules = {};

    const computedDependencyExtractorRunning = false;
    const extractedComputedDependencies = new Set();
    const currentReactiveVariableReference = "";

    const dependencyExtractorRunning = false;
    const extractedDependencies = new Set();

    // Effects
    const queueReactiveEffect = (
        newReactiveEffect,
        configuration = { runOnQueue: true }
    ) => {
        $FlowEngine.dependencyExtractorRunning = true;

        if (configuration.runOnQueue === undefined || configuration.runOnQueue) {
            newReactiveEffect.effect();
        }

        if ($FlowEngine.extractedDependencies.size > 0) {
            const extractedDependencies = Array.from(
                $FlowEngine.extractedDependencies
            );

            if (extractedDependencies.length > 0) {
                newReactiveEffect.references = extractedDependencies;

                reactiveEffects.push(newReactiveEffect);
            }

            $FlowEngine.extractedDependencies = new Set();
        }

        $FlowEngine.dependencyExtractorRunning = false;
    };

    const runReactiveEffects = ({
        reference: reactiveVariableReference,
        configuration = {},
    }) => {
        if ($FlowEngine.lastInfluencedEffectReference === reactiveVariableReference) return;

        $FlowEngine.lastInfluencedEffectReference = reactiveVariableReference;

        reactiveEffects.forEach(
            ({ references: reactiveEffectReferences, effect: reactiveEffect }) => {
                reactiveEffectReferences.forEach((effectReference) => {
                    if (effectReference === reactiveVariableReference) {
                        reactiveEffect();

                        configuration.influences.forEach((influencedReference) => {
                            const influencedReferenceConfiguration = reactiveVariables[reactiveVariableReference].configuration || {};

                            runReactiveEffects({
                                reference: influencedReference,
                                configuration: influencedReferenceConfiguration,
                            });
                        });
                    }
                });
            }
        );

        $FlowEngine.lastInfluencedEffectReference = "";
    };

    const defineComponentModule = (componentModule, customComponentName = "") => {
        // TODO: This 'find' instruction is not checking whether the found 'function' is an actual component.
        let componentFunction = Object.values(componentModule).find(
            (value) => typeof value === "function"
        );

        const upperCaseComponentName = (customComponentName || componentFunction.name).toUpperCase();

        $FlowEngine.templateByComponent[upperCaseComponentName] =
            componentModule["Template"] || ``;

        $FlowEngine.styleByComponent[upperCaseComponentName] =
            componentModule["Style"] || ``;

        $FlowEngine.propertiesByComponent[upperCaseComponentName] =
            componentModule["Props"] || [];

        $FlowEngine.eventsByComponent[upperCaseComponentName] =
            componentModule["Emits"] || [];

        componentModules[upperCaseComponentName] = {
            componentFunction,
            componentName: customComponentName || componentFunction.name,
        };
    };

    const defineStore = (storeFunction) => {
        const storeName = storeFunction.name;

        const storeGenerationFunction = generateStore(storeName, storeFunction);

        storeGenerationQueue.push(storeGenerationFunction);
    };

    return {
        componentModules,
        defineComponentModule,

        templateByComponent,
        propertiesByComponent,
        eventsByComponent,
        styleByComponent,
        mountedStyleByComponent,

        reactiveVariables,
        stores,
        storeGenerationQueue,
        defineStore,

        effects: reactiveEffects,
        lastInfluencedEffectReference,
        watchCallbacks,
        queueReactiveEffect,
        runReactiveEffects,

        computedDependencyExtractorRunning,
        extractedComputedDependencies,
        currentReactiveVariableReference,

        dependencyExtractorRunning,
        extractedDependencies,
    };
})();

// * Temporary implemetation of the router aka. "the real router"
const routerStore = ({ ref }) => {
    const path = ref("/");

    return {
        path,
    };
};

const routerStoreGenerationFunction = generateStore("routerStore", routerStore);
$FlowEngine.storeGenerationQueue.push(routerStoreGenerationFunction);
