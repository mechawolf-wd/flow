import { templateCompiler } from './src/templateCompiler.js'
import { showErrorOverlay } from './utils/showErrorOverlay.js'

export const Flow = {
    connect(callback) {
        try {
            callback()
        } catch (error) {
            showErrorOverlay(error)
        }
    },
    mountStore(callback) {
        callback()
    },
    mount: templateCompiler
};

window.$Flow = (() => {
    const effects = [];
    const stores = []
    const components = {}
    const watchCallbacks = {}

    const computedDependencyExtractorRunning = false
    const extractedDependencies = new Set()
    const currentSignalReference = ''

    const reactiveVariableDictionary = {}

    // ------------ EFFECTS ------------
    const queueEffect = (newEffect) => {
        // Immediately calling the effect, eg. replacing innerText or changing attribute value.
        newEffect.effect()

        // Queueing effect so that it can be called in the future once its dependencies change their values.
        effects.push(newEffect)
    }

    const runEffects = ({ reference: reactiveReference, configuration = {} }) => {
        // Loop through the queued effects.
        effects.forEach(({ references: effectReferences, effect }) => {
            // Calling every effect that has variableReference in its references array.
            effectReferences.forEach((effectReference) => {
                if (effectReference === reactiveReference && typeof effect === 'function') {
                    // Calling the effect eg. replacing innerText or changing attribute value.
                    effect()

                    configuration?.influences?.forEach((influencedReference) => {
                        const influencedReferenceConfiguration = $Flow.reactiveVariableDictionary[influencedReference]?.configuration || {}

                        runEffects({ reference: influencedReference, configuration: influencedReferenceConfiguration })
                    })
                }
            })
        })
    }

    const flushEffects = () => {
        effects.length = []
    }

    // ------------ STORE ------------
    const setStore = (name, store) => {
        stores.push({
            name,
            store
        })
    }

    const useStore = (storeName) => {
        const storeDefinition = stores.find(store => {
            return store.name === storeName
        })

        return storeDefinition.store
    }

    return {
        effects,
        stores,
        components,
        watchCallbacks,
        computedDependencyExtractorRunning,
        extractedDependencies,
        currentSignalReference,
        reactiveVariableDictionary,

        runEffects,
        flushEffects,
        queueEffect,
        setStore,
        useStore
    }
})()