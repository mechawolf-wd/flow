import { templateCompiler } from "./src/templateCompiler.js";
import { showErrorOverlay } from "./utils/showErrorOverlay.js";
import { generateStore } from "../@flow/store/generateStore.js";

const DEFAULT_ENTRY_POINT_COMPONENT_NAME = "App";
const DEFAULT_ENTRY_POINT_ELEMENT_ID = "app";

const callWithErrorOverlay = ((callback) => {
    try {
        callback()
    } catch (error) {
        showErrorOverlay(error);
    }
})

export const Flow = {
    render() {
        callWithErrorOverlay(() => {
            const defaultEntryPointComponentFunction =
                $FlowEngine.components[DEFAULT_ENTRY_POINT_COMPONENT_NAME].componentFunction;

            templateCompiler(
                DEFAULT_ENTRY_POINT_COMPONENT_NAME,
                defaultEntryPointComponentFunction,
                document.body,
                DEFAULT_ENTRY_POINT_ELEMENT_ID
            );
        })
    },
    defineComponents(components) {
        components.forEach((componentFunction) => {
            $FlowEngine.defineComponent(componentFunction)
        })
    },
    defineStores(stores) {
        stores.forEach((storeFunction) => {
            $FlowEngine.defineStore(storeFunction)
        })
    }
};

window.$FlowEngine = (() => {
    const effects = [];
    const stores = [];
    const components = {};
    const watchCallbacks = {};

    const computedDependencyExtractorRunning = false;
    const extractedDependencies = new Set();
    const currentSignalReference = "";

    const reactiveVariables = {};

    // ------------ EFFECTS ------------
    const queueEffect = (newEffect) => {
        // Immediately calling the effect, eg. replacing innerText or changing attribute value.
        newEffect.effect();

        // Queueing effect so that it can be called in the future once its dependencies change their values.
        effects.push(newEffect);
    };

    const runEffects = ({ reference: reactiveReference, configuration = {} }) => {
        // Loop through the queued effects.
        effects.forEach(({ references: effectReferences, effect }) => {
            // Calling every effect that has variableReference in its references array.
            effectReferences.forEach((effectReference) => {
                if (
                    effectReference === reactiveReference &&
                    typeof effect === "function"
                ) {
                    // Calling the effect eg. replacing innerText or changing attribute value.
                    effect();

                    configuration?.influences?.forEach((influencedReference) => {
                        const influencedReferenceConfiguration =
                            $FlowEngine.reactiveVariables[influencedReference]
                                ?.configuration || {};

                        runEffects({
                            reference: influencedReference,
                            configuration: influencedReferenceConfiguration,
                        });
                    });
                }
            });
        });
    };

    const flushEffects = () => {
        effects.length = [];
    };

    // ------------ STORE ------------
    const setStore = (name, store) => {
        stores.push({
            name,
            store,
        });
    };

    const useStore = (storeName) => {
        const storeDefinition = stores.find((store) => {
            return store.name === storeName;
        });

        return storeDefinition.store;
    };

    const defineStore = (storeFunction) => {
        const storeName = storeFunction.name

        const setupStore = generateStore(storeName, storeFunction);

        setupStore();
    };

    // ------------ COMPONENTS ------------
    const defineComponent = (componentFunction) => {
        const componentName = componentFunction.name

        components[componentName] = { componentFunction, meta: { timesUsed: 0 } };
    };

    return {
        effects,
        stores,
        components,
        watchCallbacks,
        computedDependencyExtractorRunning,
        extractedDependencies,
        currentSignalReference,
        reactiveVariables,

        runEffects,
        flushEffects,
        queueEffect,
        setStore,
        useStore,
        defineStore,
        defineComponent,
    };
})();
