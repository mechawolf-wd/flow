import { extractLoopDescriptors } from '../../../utils/extractLoopDescriptors.js'
import { evaluateJSExpression } from '../../../utils/evaluateJSExpression.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../../../utils/getTranslatedAttributeNames.js'
import { getExpressionDependencies } from '../../../utils/getExpressionDependencies.js'
import { bindIfDirective } from './if.js'

export const bindForDirective = (mappedInnerLoopNode, componentContext) => {
    // Extracting the :for attribute content, eg. item in items.
    const loopAttributeContent = mappedInnerLoopNode.element.getAttribute('data-flow-attribute-original-content-for')

    // Extracting the array and item name from the :for attribute and array's expression, eg. { arrayExpression: items, itemName: item }.
    const loopDescriptors = extractLoopDescriptors(loopAttributeContent)

    // Evaluating the array that will be looped, eg. items.
    const evaluatedTargetArray = evaluateJSExpression(componentContext, loopDescriptors.arrayExpression)

    // Extracting the HTML template of the looped element, eg. <div>{{ item }}</div>.
    const loopHTMLItemTemplate = mappedInnerLoopNode.element.innerHTML

    const effect = () => {
        // Resetting the innerHTML of the looped element.
        mappedInnerLoopNode.element.innerHTML = ''

        // Looping through the array and creating a new element for each item.
        evaluatedTargetArray.value.forEach((arrayElement) => {
            const currentLoopedElement = document.createElement('looped-element')

            currentLoopedElement.innerHTML = loopHTMLItemTemplate

            const loopedElementInnerNodes = [...currentLoopedElement.querySelectorAll('*')]

            let mappedInnerLoopElements = loopedElementInnerNodes.map((innerNode) => {
                const attributes = [...innerNode.attributes]

                if (attributes.length === 0) return

                return {
                    element: innerNode,
                    attributes: getTranslatedAttributeNames(attributes)
                }
            })

            mappedInnerLoopElements = mappedInnerLoopElements.filter(Boolean)

            const loopedElementContext = { ...componentContext, [loopDescriptors.itemName]: arrayElement }

            mappedInnerLoopElements.forEach(loopNode => {
                loopNode.attributes.eventAttributes.forEach(({ name: bindingAttribute, value }) => {
                    loopNode.element.addEventListener(translateEventAttribute(bindingAttribute), evaluateJSExpression(loopedElementContext, value))
                })

                loopNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
                    const dependencies = getExpressionDependencies(value)
                    const attributeReferences = []

                    Object.entries(loopedElementContext).forEach(([variableName, value]) => {
                        if (!value.configuration?.isReactiveVariable) return

                        if (dependencies.includes(variableName)) {
                            attributeReferences.push(value.variableReference)
                        }
                    })

                    if (attribute === ':if') {
                        loopNode.element.setAttribute('data-flow-attribute-original-content-if', value)

                        bindIfDirective(loopNode, loopedElementContext, attributeReferences)

                        return
                    }

                    const isNodeATextInput = attribute === ':value' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'text' || !loopNode.element.hasAttribute('type'))

                    if (isNodeATextInput) {
                        $FlowEngine.queueEffect({
                            references: attributeReferences,
                            effect: () => {
                                loopNode.element.value = evaluateJSExpression(loopedElementContext, value, attributeReferences)
                            }
                        })

                        return
                    }

                    const isNodeACheckboxInput = attribute === ':checked' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'checkbox')

                    if (isNodeACheckboxInput) {
                        $FlowEngine.queueEffect({
                            references: attributeReferences,
                            effect: () => {
                                const condition = evaluateJSExpression(loopedElementContext, value, attributeReferences)

                                if (condition) {
                                    loopNode.element.setAttribute('checked', condition)
                                } else {
                                    loopNode.element.removeAttribute('checked')
                                }
                            }
                        })

                        return
                    }

                    $FlowEngine.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            loopNode.element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(loopedElementContext, value, attributeReferences))
                        }
                    })
                })
            })

            const interpolationNodes = [...currentLoopedElement.querySelectorAll('flow-paint')]

            interpolationNodes.forEach(interpolationNode => {
                const expression = interpolationNode['data-flow-paint-expression'] ??= interpolationNode.textContent
                const dependencies = getExpressionDependencies(interpolationNode.textContent)

                const interpolationNodeReferences = []

                Object.entries(loopedElementContext).forEach(([variableName, value]) => {
                    if (!value.configuration?.isReactiveVariable) return

                    if (dependencies.includes(variableName)) {
                        interpolationNodeReferences.push(value.variableReference)
                    }
                })

                const textNode = document.createTextNode('')

                interpolationNode.parentNode.insertBefore(textNode, interpolationNode)
                interpolationNode.parentNode.removeChild(interpolationNode)

                const effect = () => {
                    textNode.textContent = evaluateJSExpression(loopedElementContext, expression, interpolationNodeReferences)
                }

                $FlowEngine.queueEffect({
                    references: interpolationNodeReferences,
                    effect
                })
            })

            mappedInnerLoopNode.element.append(...currentLoopedElement.childNodes)
        })
    }

    $FlowEngine.queueEffect({
        references: [evaluatedTargetArray.variableReference],
        effect
    })
}
