import { evaluateJSExpression } from '../utils/evaluateJSExpression.js'
import { replaceInterpolationMarkers } from '../utils/formatTemplate.js'
import { bindForDirective } from './compiler/directives/for.js'
import { bindIfDirective } from './compiler/directives/if.js'
import { getExpressionDependencies } from '../utils/getExpressionDependencies.js'
import { determineUsedComponents } from '../utils/determineUsedComponents.js'
import { mountStyling } from '../src/mountStyling.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../utils/getTranslatedAttributeNames.js'
import { reactiveVariable, createReactiveArray } from '../reactivity/reactiveVariable.js'

const REACTIVE_VARIABLE_REF_CONFIG = {
    isStored: false,
    isRef: true,
    isComputed: false,
    isProp: false,

    influences: []
}

const REACTIVE_VARIABLE_COMPUTED_CONFIG = {
    isStored: false,
    isRef: false,
    isComputed: true,
    isProp: false,

    influences: [],
    dependsOn: []
}

const REACTIVE_VARIABLE_PROP_CONFIG = {
    isStored: false,
    isRef: false,
    isComputed: false,
    isProp: true,

    influences: []
}

const LIFECYCLE_CALLBACK_TEMPLATE = {
    onMounted: undefined,
    onBeforeMount: undefined
}

const camelizeKebabCasedString = string => string.replace(/-./g, character => character[1].toUpperCase())

export function compileComponent(componentFunction = () => { }, componentParentNode = {}, parentContext = {}) {
    componentParentNode.$FlowComponent = {}

    const lifecycleCallbacks = structuredClone(LIFECYCLE_CALLBACK_TEMPLATE)

    const properties = componentParentNode.$FlowComponent.properties = {}

    // Binding props and transforming them into reactive variables.
    let componentProperties = $FlowEngine.propertiesByComponent[componentParentNode.tagName] || [] //  - in case the parent node's tagName is 'DIV'.

    componentProperties.forEach((propertyName) => {
        const attributeExpression = componentParentNode.getAttribute(`data-flow-attribute-original-content-${propertyName}`)

        const camelCasePropertyName = camelizeKebabCasedString(propertyName)

        const propertyReactiveVariable = properties[camelCasePropertyName] = reactiveVariable(undefined, structuredClone(REACTIVE_VARIABLE_PROP_CONFIG))

        const dependencies = getExpressionDependencies(attributeExpression)
        const propertyReferences = []

        Object.entries(parentContext).forEach(([variableName, value]) => {
            if (!value.configuration?.isReactiveVariable) return

            if (dependencies.includes(variableName)) {
                propertyReferences.push(value.variableReference)
            }
        })

        $FlowEngine.queueEffect({
            references: propertyReferences,
            effect: () => {
                propertyReactiveVariable.value = evaluateJSExpression(parentContext, attributeExpression, propertyReferences)
            }
        })
    })

    // Defining component's destructurable properties.
    const componentContextMethods = {
        emit: (eventName, payload, eventInitDict = { bubbles: true }) => {
            eventInitDict.detail = payload

            const customEvent = new CustomEvent(eventName, eventInitDict)

            componentParentNode.dispatchEvent(customEvent)
        },
        ref: (value) => {
            return reactiveVariable(value, structuredClone(REACTIVE_VARIABLE_REF_CONFIG))
        },
        computed: (callback) => {
            return reactiveVariable(callback, structuredClone(REACTIVE_VARIABLE_COMPUTED_CONFIG))
        },
        useStore: (storeName) => {
            const store = $FlowEngine.useStore(storeName)

            return store
        },
        watch: (source, callback, watchConfiguration) => {
            if (!source.configuration?.isReactiveVariable) return

            const variableReference = source.variableReference

            if (watchConfiguration?.immediate) {
                callback(source.value, source.value)
            }

            $FlowEngine.watchCallbacks[variableReference].push(callback)
        },
        onMounted: (callback) => {
            lifecycleCallbacks.onMounted = callback
        },
        onBeforeMount: (callback) => {
            lifecycleCallbacks.onBeforeMount = callback
        },
        props: componentParentNode.$FlowComponent.properties
    }

    // Calling a component function with the context methods. The component function returns a context object.
    // It is fine to think of it as Vue's onCreated lifecycle hook.
    const componentContext = Object.assign(properties, componentFunction(componentContextMethods))

    // Setting componentParentNode's innerHTML to the component's template and removing the 'template' property.
    const componentTemplate = componentContext.template
    delete componentContext.template

    componentParentNode.innerHTML = replaceInterpolationMarkers(componentTemplate)

    const componentStyle = componentContext.style
    delete componentContext.style

    // Invoking onBeforeMount lifecycle hook if defined.
    lifecycleCallbacks.onBeforeMount?.()

    // Setting parent's innerHTML.
    componentParentNode.innerHTML = replaceInterpolationMarkers(componentTemplate)

    // Grabbing all inner elements of the componentParentNode that has just been created by innerHTML property.
    const componentNodeInnerElements = [...componentParentNode.querySelectorAll('*')]

    // Formatting every inner node in order for easier manipulation.
    let mappedInnerElements = componentNodeInnerElements.map((element) => {
        const attributes = [...element.attributes];

        if (attributes.length === 0) return

        return {
            element,
            attributes: getTranslatedAttributeNames(attributes)
        }
    })

    // Filtering out every element that has NO user-defined attributes.
    mappedInnerElements = mappedInnerElements.filter(Boolean)

    // This is so-called "loop-marking". It is used to distinguish looped elements from the rest.
    // This because loops are mounted separately from the rest of the component.
    const loopNodes = [...componentParentNode.querySelectorAll('Loop')]

    loopNodes.forEach(element => {
        const loopBlockElements = [...element.querySelectorAll('*')]

        loopBlockElements.forEach((loopBlockElement) => {
            loopBlockElement.setAttribute('data-flow-looped-element', true)
        })
    })

    // Determining which components are used in the component's template and converting their names to uppercase.
    const componentNamesUsed = determineUsedComponents(componentTemplate)

    // The famous "mounting" step. This is where the magic happens.
    mappedInnerElements.forEach((mappedInnerNode) => {
        // Mounting event attributes that start with '@' character.
        mappedInnerNode.attributes.eventAttributes.forEach(({ name: eventAttribute, value }) => {
            mappedInnerNode.element.addEventListener(translateEventAttribute(eventAttribute), evaluateJSExpression(componentContext, value))
        })

        // Mounting binding attributes that start with ':' character.
        mappedInnerNode.attributes.bindingAttributes.forEach(({ name: bindingAttribute, value }) => {
            const translatedBindingAttribute = translateBindingAttribute(bindingAttribute)

            mappedInnerNode.element.setAttribute(`data-flow-attribute-original-content-${translatedBindingAttribute}`, value)

            // Note: for loop is mounted separately from other elements and has its own mounting (copied) step.
            if (bindingAttribute === ':for') {
                bindForDirective(mappedInnerNode, componentContext)

                return
            }

            const isNodeNotAChildOfLoopElement = !mappedInnerNode.element.getAttribute('data-flow-looped-element')

            // Determining which variables are used in the binding attribute's value.
            // So that the effect can be triggered when any of these variables change.
            const dependencies = getExpressionDependencies(value)
            const attributeReferences = []

            Object.entries(componentContext).forEach(([variableName, value]) => {
                if (!value.configuration?.isReactiveVariable) return

                if (dependencies.includes(variableName)) {
                    attributeReferences.push(value.variableReference)
                }
            })

            // Mounting :if directive.
            if (isNodeNotAChildOfLoopElement) {
                if (bindingAttribute === ':if') {
                    bindIfDirective(mappedInnerNode, componentContext, attributeReferences)

                    return
                }

                // Mounting input elements' value and checked attributes.
                const isNodeATextInput = bindingAttribute === ':value' && mappedInnerNode.element.tagName === 'INPUT' && (mappedInnerNode.element.getAttribute('type') === 'text' || !mappedInnerNode.element.hasAttribute('type'))

                if (isNodeATextInput) {
                    $FlowEngine.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            mappedInnerNode.element.value = evaluateJSExpression(componentContext, value, attributeReferences)
                        }
                    })

                    return
                }

                const isNodeACheckboxInput = bindingAttribute === ':checked' && mappedInnerNode.element.tagName === 'INPUT' && mappedInnerNode.element.getAttribute('type') === 'checkbox';

                if (isNodeACheckboxInput) {
                    $FlowEngine.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            const condition = evaluateJSExpression(componentContext, value, attributeReferences)

                            if (condition) {
                                mappedInnerNode.element.setAttribute('checked', condition)
                            } else {
                                mappedInnerNode.element.removeAttribute('checked')
                            }
                        }
                    })

                    return
                }

                // Mounting any other attribute that is not a directive.
                $FlowEngine.queueEffect({
                    references: attributeReferences,
                    effect: () => {
                        mappedInnerNode.element.setAttribute(translatedBindingAttribute, evaluateJSExpression(componentContext, value, attributeReferences))
                    }
                })
            }
        })
    })

    // This is used to bind reactive variables to the DOM that are not part of a loop and evaluate expressions inside {{ }} delimiters
    const interpolationNodes = [...componentParentNode.querySelectorAll('flow-paint')].filter(element => !element.closest('Loop'))

    interpolationNodes.forEach(interpolationNode => {
        const expression = interpolationNode['data-flow-paint-expression'] ??= interpolationNode.textContent
        const dependencies = interpolationNode['data-flow-paint-expression-dependencies'] ??= getExpressionDependencies(interpolationNode.textContent)

        const interpolationNodeReferences = []

        Object.entries(componentContext).forEach(([variableName, value]) => {
            if (!value.configuration?.isReactiveVariable) return

            if (dependencies.includes(variableName)) {
                interpolationNodeReferences.push(value.variableReference)
            }
        })

        const textNode = document.createTextNode('')

        interpolationNode.parentNode.insertBefore(textNode, interpolationNode)
        interpolationNode.parentNode.removeChild(interpolationNode)

        const effect = () => {
            textNode.textContent = evaluateJSExpression(componentContext, expression, interpolationNodeReferences)
        }

        $FlowEngine.queueEffect({
            references: interpolationNodeReferences,
            effect
        })
    })

    // Calling the onMounted lifecycle callback if it exists
    lifecycleCallbacks.onMounted?.()

    mountStyling(componentStyle, componentParentNode)

    return { componentNodeReference: componentParentNode, componentNamesUsed, nextParentContext: componentContext }
}

export function templateCompiler(componentFunction, lookUpNode, defaultEntryPointId, previousParentContext) {
    let componentNodes = []

    const componentName = componentFunction.name.toUpperCase()

    if (defaultEntryPointId) {
        componentNodes = [...lookUpNode.querySelectorAll(defaultEntryPointId)]
    } else {
        componentNodes = [...lookUpNode.querySelectorAll(`${componentName}:not([data-flow-compiled-component])`)];
    }

    componentNodes.forEach((componentParentNode) => {
        const { componentNodeReference, componentNamesUsed, nextParentContext } = compileComponent(componentFunction, componentParentNode, previousParentContext)

        if (componentNamesUsed.includes(componentName)) {
            throw new Error(`Component "${componentName}" tries to render itself.`)
        }

        componentParentNode.setAttribute('data-flow-compiled-component', true)

        componentParentNode.prepend(...componentNodeReference.childNodes)

        componentNamesUsed.forEach(componentName => {
            if (!$FlowEngine.componentModules[componentName]) return

            const componentModule = $FlowEngine.componentModules[componentName]

            templateCompiler(componentModule.componentFunction, componentParentNode, undefined, nextParentContext)
        });
    })
}