import { evaluateJSExpression } from '../utils/evaluateJSExpression.js'
import { replaceInterpolationMarkers, replaceSelfClosingTags } from '../utils/formatTemplate.js'
import { extractLoopDescriptors } from '../utils/extractLoopDescriptors.js'
import { getExpressionDependencies } from '../utils/getExpressionDependencies.js'
import { mountStyling } from '../src/mountStyling.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../utils/getTranslatedAttributeNames.js'
import { reactiveVariable, createReactiveArray, generateNewReference } from '../reactivity/reactiveVariable.js'

export function compileTemplate(componentDefinition, componentName, parentNode) {
    const componentNodeReference = document.createElement(`${componentName}-component`) // DOM reference

    const componentNodeId = generateNewReference()

    const lifecycleCallbacks = {}

    const componentContextMethods = {
        emit: (eventName, payload, eventInitDict = { bubbles: true }) => {
            eventInitDict.detail = payload

            const customEvent = new CustomEvent(eventName, eventInitDict)

            componentNodeReference.dispatchEvent(customEvent)
        },
        ref: (value) => {
            return reactiveVariable(value, { isStored: false, isRef: true, isComputed: false, influences: [] })
        },
        computed: (callback) => {
            return reactiveVariable(callback, { isStored: false, isRef: false, isComputed: true, influences: [], dependsOn: [] })
        },
        useStore: (storeName) => {
            const store = $Flow.useStore(storeName)

            return store
        },
        watch: (source, callback) => {
            const isRef = source.configuration?.isRef
            const isComputed = source.configuration?.isComputed

            if (isRef || isComputed) {
                const variableReference = source.variableReference

                $Flow.watchCallbacks[variableReference].push(callback)
            }
        },
        onMounted: (lifecycleCallback) => {
            lifecycleCallbacks.onMounted = lifecycleCallback
        },
        onBeforeMount: (lifecycleCallback) => {
            lifecycleCallbacks.onBeforeMount = lifecycleCallback
        }
    }

    const componentContext = componentDefinition.setup(parentNode.attributes, componentContextMethods)

    // ------------ LIFECYCLE HOOK onBeforeMount ------------
    lifecycleCallbacks.onBeforeMount?.()

    // ------------ PARSING HTML ------------
    componentNodeReference.innerHTML = replaceSelfClosingTags(replaceInterpolationMarkers(componentContext.template))

    // ------------ BINDING EVENTS AND REACTIVE ATTRIBUTES ------------
    const componentNodeInnerElements = [...componentNodeReference.querySelectorAll('*')]

    const mappedInnerElements = componentNodeInnerElements.map((element) => {
        const attributes = [...element.attributes];

        if (attributes.length === 0) return

        return {
            element,
            attributes: getTranslatedAttributeNames(attributes)
        }
    }).filter(Boolean)

    // ------------ LOOP MARKING STEP ------------
    // Used to distinguish looped elements from the rest
    const loopNodes = [...componentNodeReference.querySelectorAll('Loop')]

    loopNodes.forEach(block => {
        const loopBlockElements = [...block.querySelectorAll('*')]

        loopBlockElements.forEach((loopBlockElement) => {
            loopBlockElement['data-flow-looped'] = true
        })
    })

    // ------------ BINDING AND EVALUATION OF EXPRESSION ELEMENTS + RESTRICTING LOOP ELEMENT ------------
    // Used to bind reactive variables to the DOM that are not part of a loop and evaluate expressions inside {{ }} delimiters
    const standaloneBindingNodes = [...componentNodeReference.querySelectorAll('Paint')].filter(element => !element.closest('Loop'))

    standaloneBindingNodes.forEach(paintNode => {
        const expression = paintNode['data-flow-paint-expression'] ??= paintNode.textContent
        const dependencies = paintNode['data-flow-paint-expression-dependencies'] ??= getExpressionDependencies(paintNode.textContent)

        const paintNodeReferences = []

        Object.entries(componentContext).forEach(([key, value]) => {
            if (value.configuration?.isReactiveVariable && dependencies?.includes(key)) {
                paintNodeReferences.push(value.variableReference)
            }
        })

        const effect = () => {
            paintNode.textContent = evaluateJSExpression(componentContext, expression)
        }

        $Flow.queueEffect({
            references: paintNodeReferences,
            effect
        })
    })

    // ------------ MOUNTING STEP ------------
    mappedInnerElements.forEach((componentInnerNode) => {
        componentInnerNode.attributes.eventAttributes.forEach(({ name: key, value }) => {
            componentInnerNode.element.addEventListener(translateEventAttribute(key), evaluateJSExpression(componentContext, value))
            componentInnerNode.element.removeAttribute(key)
        })

        componentInnerNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
            // Note: for loop is mounted separately from other elements and has its own mounting (copied) step.
            if (attribute === ':for') {
                const effect = () => {
                    // Extracting the :for attribute content, eg. item in items.
                    const forAttributeContent = componentInnerNode['data-flow-loop-attribute-content'] ??= componentInnerNode.element.getAttribute(':for')

                    // Extracting the array and item name from the :for attribute and array's expression, eg. { arrayExpression: items, itemName: item }.
                    const loopDescriptors = extractLoopDescriptors(forAttributeContent)

                    // Evaluating the array that will be looped, eg. items.
                    const evaluatedTargetArray = evaluateJSExpression(componentContext, loopDescriptors.arrayExpression)

                    // Extracting the HTML template of the looped element, eg. <div>{{ item }}</div>.
                    const loopHTMLItemTemplate = componentInnerNode['data-flow-loop-html-template'] ??= componentInnerNode.element.innerHTML

                    // Resetting the innerHTML of the looped element.
                    componentInnerNode.element.innerHTML = ''

                    // Looping through the array and creating a new element for each item.
                    evaluatedTargetArray.forEach((arrayElement) => {
                        const currentLoopedElement = document.createElement('looped-element')

                        currentLoopedElement.innerHTML = loopHTMLItemTemplate

                        const loopedElementInnerNodes = [...currentLoopedElement.querySelectorAll('*')]

                        const customLoopAttributes = loopedElementInnerNodes.map((element) => {
                            const attributes = [...element.attributes]

                            if (attributes.length === 0) return

                            return {
                                element,
                                attributes: getTranslatedAttributeNames(attributes)
                            }
                        }).filter(Boolean)

                        const loopedElementContext = { ...componentContext, [loopDescriptors.itemName]: arrayElement }

                        customLoopAttributes.forEach(loopNode => {
                            loopNode.attributes.eventAttributes.forEach(({ name: attribute, value }) => {
                                loopNode.element.addEventListener(translateEventAttribute(attribute), () => {
                                    evaluateJSExpression(loopedElementContext, value)
                                })
                            })

                            loopNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
                                const dependencies = getExpressionDependencies(value)
                                const attributeReferences = []

                                Object.entries(loopedElementContext).forEach(([key, value]) => {
                                    if (value.configuration?.isReactiveVariable && dependencies.includes(key)) {
                                        attributeReferences.push(value.variableReference)
                                    }
                                })

                                loopNode.element.removeAttribute(attribute)

                                if (attribute === ':if') {
                                    $Flow.queueEffect({
                                        references: attributeReferences,
                                        effect: () => {
                                            const display = Boolean(evaluateJSExpression(loopedElementContext, value))

                                            loopNode.element.style.display = display ? 'initial' : 'none'
                                        }
                                    })

                                    return
                                }

                                const isNodeATextInput = attribute === ':value' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'text' || !loopNode.element.hasAttribute('type'))

                                if (isNodeATextInput) {
                                    $Flow.queueEffect({
                                        references: attributeReferences,
                                        effect: () => {
                                            loopNode.element.value = evaluateJSExpression(loopedElementContext, value)
                                        }
                                    })

                                    return
                                }

                                const isNodeACheckboxInput = attribute === ':checked' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'checkbox')

                                if (isNodeACheckboxInput) {
                                    $Flow.queueEffect({
                                        references: attributeReferences,
                                        effect: () => {
                                            const condition = evaluateJSExpression(loopedElementContext, value)

                                            if (condition) {
                                                loopNode.element.setAttribute('checked', condition)
                                            } else {
                                                loopNode.element.removeAttribute('checked')
                                            }
                                        }
                                    })

                                    return
                                }

                                $Flow.queueEffect({
                                    references: attributeReferences,
                                    effect: () => {
                                        loopNode.element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(loopedElementContext, value))
                                    }
                                })
                            })
                        })

                        const paintForBlocks = [...currentLoopedElement.querySelectorAll('Paint')]

                        paintForBlocks.forEach(paintBlock => {
                            const expression = paintBlock['data-flow-paint-expression'] ??= paintBlock.textContent
                            const dependencies = getExpressionDependencies(paintBlock.textContent)

                            const paintNodeReferences = []

                            Object.entries(loopedElementContext).forEach(([key, value]) => {
                                if (value.configuration?.isReactiveVariable && dependencies.includes(key)) {
                                    paintNodeReferences.push(value.variableReference)
                                }
                            })

                            const effect = () => {
                                paintBlock.textContent = evaluateJSExpression(loopedElementContext, expression)
                            }

                            $Flow.queueEffect({
                                references: paintNodeReferences,
                                effect
                            })
                        })

                        componentInnerNode.element.append(...currentLoopedElement.childNodes)
                    })
                }

                $Flow.queueEffect({
                    references: [componentNodeId],
                    effect
                })

                componentInnerNode.element.removeAttribute(attribute)

                return
            }

            const isNodeNotAChildOfLoopElement = !componentInnerNode.element['data-flow-looped']

            componentInnerNode.element.removeAttribute(attribute)

            // ---- EVALUTING ATTRIBUTE'S REACTIVE DEPENDENCIES ----
            const dependencies = getExpressionDependencies(value)
            const attributeReferences = []

            Object.entries(componentContext).forEach(([key, value]) => {
                if (value.configuration?.isReactiveVariable && dependencies?.includes(key)) {
                    attributeReferences.push(value.variableReference)
                }
            })

            // ---- MOUNTING :if DIRECTIVE ----
            if (isNodeNotAChildOfLoopElement) {
                if (attribute === ':if') {
                    $Flow.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            const display = Boolean(evaluateJSExpression(componentContext, value))

                            componentInnerNode.element.style.display = display ? 'initial' : 'none'
                        }
                    })

                    return
                }

                // ---- MOUNTING INPUT ELEMENTS ----
                const isNodeATextInput = attribute === ':value' && componentInnerNode.element.tagName === 'INPUT' && (componentInnerNode.element.getAttribute('type') === 'text' || !componentInnerNode.element.hasAttribute('type'))

                if (isNodeATextInput) {
                    $Flow.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            componentInnerNode.element.value = evaluateJSExpression(componentContext, value)
                        }
                    })

                    return
                }

                const isNodeACheckboxInput = attribute === ':checked' && componentInnerNode.element.tagName === 'INPUT' && componentInnerNode.element.getAttribute('type') === 'checkbox';

                if (isNodeACheckboxInput) {
                    $Flow.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            const condition = evaluateJSExpression(componentContext, value)

                            if (condition) {
                                componentInnerNode.element.setAttribute('checked', condition)
                            } else {
                                componentInnerNode.element.removeAttribute('checked')
                            }
                        }
                    })

                    return
                }

                // ---- MOUNTING ANY OTHER ATTRIBUTE ----
                $Flow.queueEffect({
                    references: attributeReferences,
                    effect: () => {
                        componentInnerNode.element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(componentContext, value))
                    }
                })
            }
        })
    })

    // ------------ LIFECYCLE HOOK onMounted ------------
    lifecycleCallbacks.onMounted?.()

    return componentNodeReference
}

export function templateCompiler(componentFunction, entryPoint = document.body) {
    // Extracting the component definition from the function that defines it, eg. export const Counter = () => ...
    const component = componentFunction()

    // Extracting the component name from the function that defines it, eg. export const Counter = () => ...
    const componentName = componentFunction.name

    // Selecting all component nodes that are defined inside the entryPoint, eg. <Counter></Counter>.
    const nodes = [...entryPoint.querySelectorAll(componentName)]

    // Mounting the component to the entryPoint, eg. <Counter></Counter>
    nodes.forEach((componentEntryPoint) => {
        const componentNode = compileTemplate(component, componentName, componentEntryPoint)

        mountStyling(component, componentNode)

        componentEntryPoint.prepend(componentNode)
    })

    return nodes
}