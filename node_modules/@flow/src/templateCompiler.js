import { evaluateExpression } from '../utils/evaluateExpression.js'
import { formatTemplate, replaceSelfClosingTags } from '../utils/formatTemplate.js'
import { extractLoopDescriptors } from '../utils/extractLoopDescriptors.js'
import { mountStyling } from '../src/mountStyling.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../src/getTranslatedAttributeNames.js'
import { reactiveVariable, generateNewReference } from '../reactivity/reactiveVariable.js'

function createWatchableArray(array) {
    return new Proxy(array, {
        get(target, property, receiver) {
            const propertyOrFunctionAccessed = Reflect.get(target, property, receiver);

            if (typeof propertyOrFunctionAccessed === 'function') {
                return function (...args) {
                    if (property === 'push' || property === 'unshift' || property === 'pop' || property === 'shift') {
                        requestAnimationFrame(() => {
                            $Flow.reloadArrayLoopDOM()
                        })
                    }

                    return propertyOrFunctionAccessed.apply(this, args);
                };
            }

            return propertyOrFunctionAccessed;
        },
        set(target, property, value, receiver) {
            return Reflect.set(target, property, value, receiver);
        },
        deleteProperty(target, property) {
            return Reflect.deleteProperty(target, property);
        }
    });
}


export function generateComponent(componentDefinition, componentName, parentNode) {
    const componentReference = document.createElement(`${componentName}-component`) // DOM reference

    const newComponentID = generateNewReference()

    const lifecycleCallbacks = {}

    const componentInput = {
        emit: (eventName, payload, eventInitDict = { bubbles: true }) => {
            eventInitDict.detail = payload

            const customEvent = new CustomEvent(eventName, eventInitDict)

            componentReference.dispatchEvent(customEvent)
        },
        ref: (value) => {
            return Array.isArray(value) ? createWatchableArray(value) : reactiveVariable(value, newComponentID, { isStored: false })
        },
        computed: (value) => {
            return reactiveVariable(value, newComponentID, { isStored: false })
        },
        useStore: (name) => {
            const store = $Flow.useStore(name)

            return store
        },
        watch: (variable, callback) => {
            const variableReference = variable.variableReference

            $Flow.watchSignals[variableReference].push(callback)
        },
        onMounted: (callback) => {
            lifecycleCallbacks.onMounted = callback
        },
        onBeforeMount: (callback) => {
            lifecycleCallbacks.onBeforeMount = callback
        }
    }

    const component = componentDefinition.setup(parentNode.attributes, componentInput)

    // ==== GETTING REFERENCES ====
    const references = new Set()

    const returnedComponentObject = Object.values(component).filter(value => value?.configuration?.isReactiveVariable)

    returnedComponentObject.forEach(value => references.add(value.reference))

    const uniqueReferences = [...references]

    // === LIFECYCLE HOOK onBeforeMount ====
    lifecycleCallbacks.onBeforeMount?.()

    // ==== PARSING HTML ====
    componentReference.innerHTML = replaceSelfClosingTags(formatTemplate(component.template))

    // ==== BINDING EVENTS AND REACTIVE ATTRIBUTES ====
    const allInnerElements = [...componentReference.querySelectorAll('*')]

    const allElementsAndTheirAttributes = allInnerElements.map((element) => {
        const attributes = [...element.attributes];

        if (attributes.length === 0) return

        return {
            element,
            attributes: getTranslatedAttributeNames(attributes)
        }
    }).filter(Boolean)

    // ==== LOOP MARKING STEP ====
    const loopBlocks = [...componentReference.querySelectorAll('Loop')]

    loopBlocks.forEach(block => {
        const loopBlockElements = [...block.querySelectorAll('*')]

        loopBlockElements.forEach((loopBlockElement) => {
            loopBlockElement['data-flow-looped'] = true
        })
    })

    // ==== BINDING AND EVALUATION OF EXPRESSION ELEMENTS + RESTRICTING LOOP ELEMENT====
    const paintBlocks = [...componentReference.querySelectorAll('Paint')].filter(element => !element.closest('Loop'))

    paintBlocks.forEach(block => {
        block['data-flow-paint-expression'] = block.textContent
    })

    paintBlocks.forEach(block => {
        const expression = block['data-flow-paint-expression']

        const effect = () => {
            block.textContent = evaluateExpression(component, expression)
        }

        $Flow.queueEffect({
            references: uniqueReferences,
            effect
        })
    })

    // ==== MOUNTING STEP ====
    allElementsAndTheirAttributes.forEach((reference) => {
        reference.attributes.eventAttributes.forEach(({ name, value }) => {
            reference.element.addEventListener(translateEventAttribute(name), evaluateExpression(component, value))
            reference.element.removeAttribute(name)
        })

        reference.attributes.bindingAttributes.forEach(({ name, value }) => {
            if (name === ':for') {
                $Flow.reloadArrayLoopDOM = () => {
                    const loopAttributeContent = reference['data-flow-loop-attribute-content'] ??= reference.element.getAttribute(':for')

                    const loopDescriptors = extractLoopDescriptors(loopAttributeContent)

                    const evaluatedTargetArray = evaluateExpression(component, loopDescriptors.arrayExpression)

                    const loopHTMLItemTemplate = reference['data-flow-loop-html-template'] ??= reference.element.innerHTML

                    reference.element.innerHTML = ''

                    evaluatedTargetArray.forEach((arrayElement) => {
                        const currentLoopedElement = document.createElement('loop-item')

                        currentLoopedElement.innerHTML = loopHTMLItemTemplate

                        const itemContents = [...currentLoopedElement.querySelectorAll('*')]

                        const customLoopAttributes = itemContents.map((element) => {
                            const attributes = [...element.attributes]

                            if (attributes.length === 0) return

                            return {
                                element,
                                attributes: getTranslatedAttributeNames(attributes)
                            }
                        }).filter(Boolean)

                        const loopItemSetup = { ...component, [loopDescriptors.itemName]: arrayElement }

                        customLoopAttributes.forEach(loopNode => {
                            loopNode.attributes.eventAttributes.forEach(({ name, value }) => {
                                loopNode.element.addEventListener(translateEventAttribute(name), evaluateExpression(loopItemSetup, value))
                            })

                            loopNode.attributes.bindingAttributes.forEach(({ name, value }) => {
                                if (name === ':if') {
                                    $Flow.queueEffect({
                                        references: uniqueReferences,
                                        effect: () => {
                                            const display = Boolean(evaluateExpression(loopItemSetup, value))

                                            loopNode.element.style.display = display ? 'initial' : 'none'
                                        }
                                    })

                                    loopNode.element.removeAttribute(':if')

                                    return
                                }

                                const isAnTextInput = name === ':value' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'text' || !loopNode.element.hasAttribute('type'))

                                if (isAnTextInput) {
                                    $Flow.queueEffect({
                                        references: uniqueReferences,
                                        effect: () => {
                                            loopNode.element.value = evaluateExpression(loopItemSetup, value)
                                        }
                                    })

                                    loopNode.element.removeAttribute(':value')

                                    return
                                }

                                const isAnCheckboxInput = name === ':checked' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'checkbox' || !loopNode.element.hasAttribute('type'))

                                if (isAnCheckboxInput) {
                                    $Flow.queueEffect({
                                        references: uniqueReferences,
                                        effect: () => {
                                            const condition = evaluateExpression(loopItemSetup, value)

                                            if (condition) {
                                                loopNode.element.setAttribute('checked', '')
                                            } else {
                                                loopNode.element.removeAttribute('checked')
                                            }
                                        }
                                    })

                                    reference.element.removeAttribute(name)

                                    return
                                }

                                $Flow.queueEffect({
                                    references: uniqueReferences,
                                    effect: () => {
                                        loopNode.element.setAttribute(translateBindingAttribute(name), evaluateExpression(loopItemSetup, value))
                                        loopNode.element.removeAttribute(name)
                                    }
                                })
                            })
                        })

                        const paintForBlocks = [...currentLoopedElement.querySelectorAll('Paint')]

                        paintForBlocks.forEach(block => {
                            block['data-flow-paint-expression'] = block.textContent
                        })

                        paintForBlocks.forEach(block => {
                            const expression = block['data-flow-paint-expression']

                            const effect = () => {
                                block.textContent = evaluateExpression(loopItemSetup, expression)
                            }

                            $Flow.queueEffect({
                                references: uniqueReferences,
                                effect
                            })
                        })

                        reference.element.appendChild(currentLoopedElement)
                    })
                }

                $Flow.reloadArrayLoopDOM()

                return
            }

            const isNotAChildOfLoop = !reference.element['data-flow-looped']

            // This is why paint-for loop has a priority over if
            // loop has to know its HTML before the ifs are evaluated

            if (isNotAChildOfLoop) {
                if (name === ':if') {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            const display = Boolean(evaluateExpression(component, value))

                            reference.element.style.display = display ? 'initial' : 'none'
                        }
                    })

                    return
                }

                const isAnTextInput = name === ':value' && reference.element.tagName === 'INPUT' && (reference.element.getAttribute('type') === 'text' || !reference.element.hasAttribute('type'))

                if (isAnTextInput) {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            reference.element.value = evaluateExpression(component, value)
                        }
                    })

                    return
                }

                const isAnCheckboxInput = name === ':checked' && reference.element.tagName === 'INPUT' && (reference.element.getAttribute('type') === 'checkbox' || !reference.element.hasAttribute('type'))

                if (isAnCheckboxInput) {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            const condition = evaluateExpression(component, value)

                            if (condition) {
                                reference.element.setAttribute('checked', '')
                            } else {
                                reference.element.removeAttribute('checked')
                            }
                        }
                    })

                    return
                }

                $Flow.queueEffect({
                    references: uniqueReferences,
                    effect: () => {
                        reference.element.setAttribute(translateBindingAttribute(name), evaluateExpression(component, value))
                    }
                })

                reference.element.removeAttribute(name)
            }
        })
    })

    // === LIFECYCLE HOOK onMounted ====
    lifecycleCallbacks.onMounted?.()

    return componentReference
}

export function templateCompiler(componentDefinition, entryPoint = document.body) {
    const component = componentDefinition(entryPoint)

    const componentName = componentDefinition.name

    const nodes = [...entryPoint.querySelectorAll(componentName)]

    nodes.forEach((node) => {
        const componentNode = generateComponent(component, componentName, node)

        mountStyling(component, componentNode)

        node.prepend(componentNode)
    })

    return nodes
}