import { evaluateExpression } from '../utils/evaluateExpression.js'
import { formatTemplate, replaceSelfClosingTags } from '../utils/formatTemplate.js'
import { extractLoopDescriptors } from '../utils/extractLoopDescriptors.js'
import { mountStyling } from '../src/mountStyling.js'
import { getCustomAttributes, translateBindingAttribute, translateEventAttribute } from '../src/getCustomAttributes.js'
import { reactiveVariable, generateNewReference } from '../reactivity/reactiveVariable.js'

export function generateComponent(componentDefinition, componentName, parentNode) {
    const componentReference = document.createElement(`${componentName}-component`) // DOM reference

    const newComponentID = generateNewReference()

    const lifecycleCallbacks = {}

    const componentInput = {
        emit: (eventName, payload, eventInitDict = { bubbles: true }) => {
            eventInitDict.detail = payload

            const customEvent = new CustomEvent(eventName, eventInitDict)

            componentReference.dispatchEvent(customEvent)
        },
        ref: (value) => {
            return reactiveVariable(value, newComponentID, { isStored: false })
        },
        computed: (value) => {
            return reactiveVariable(value, newComponentID, { isStored: false })
        },
        useStore: (name) => {
            const store = $Flow.useStore(name)

            return store
        },
        watch: (variable, callback) => {
            const variableReference = variable.variableReference

            $Flow.watchSignals[variableReference].push(callback)
        },
        onMounted: (callback) => {
            lifecycleCallbacks.onMounted = callback
        },
        onBeforeMount: (callback) => {
            lifecycleCallbacks.onBeforeMount = callback
        }
    }

    const component = componentDefinition.setup(parentNode.attributes, componentInput)

    // ==== GETTING REFERENCES ====
    const references = new Set()

    const returnedComponentObject = Object.values(component).filter(value => value?.configuration?.isReactiveVariable)

    returnedComponentObject.forEach(value => references.add(value.reference))

    const uniqueReferences = [...references]

    // === LIFECYCLE HOOK onBeforeMount ====
    lifecycleCallbacks.onBeforeMount?.()

    // ==== PARSING HTML ====
    componentReference.innerHTML = replaceSelfClosingTags(formatTemplate(component.template))

    // ==== BINDING EVENTS AND REACTIVE ATTRIBUTES ====
    const allInnerElements = [...componentReference.querySelectorAll('*')]

    const allElementsAndTheirAttributes = allInnerElements.map((element) => {
        const attributes = [...element.attributes];

        if (attributes.length === 0) return

        return {
            element,
            attributes: getCustomAttributes(attributes)
        }
    }).filter(Boolean)

    // ==== LOOP MARKING STEP ====
    const loopBlocks = [...componentReference.querySelectorAll('Loop')]

    loopBlocks.forEach(block => {
        const loopBlockElements = [...block.querySelectorAll('*')]

        loopBlockElements.forEach((loopBlockElement) => {
            loopBlockElement['data-flow-looped'] = true
        })
    })

    // ==== BINDING AND EVALUATION OF EXPRESSION ELEMENTS + RESTRICTING LOOP ELEMENT====
    const paintBlocks = [...componentReference.querySelectorAll('Paint')].filter(element => !element.closest('Loop'))

    paintBlocks.forEach(block => {
        block['data-flow-paint-expression'] = block.textContent
    })

    paintBlocks.forEach(block => {
        const expression = block['data-flow-paint-expression']

        const effect = () => {
            block.textContent = evaluateExpression(component, expression)
        }

        $Flow.queueEffect({
            references: uniqueReferences,
            effect
        })
    })

    // ==== MOUNTING STEP ====
    allElementsAndTheirAttributes.forEach((reference) => {
        reference.attributes.eventAttributes.forEach(({ name, value }) => {
            reference.element.addEventListener(translateEventAttribute(name), evaluateExpression(component, value))
            reference.element.removeAttribute(name)
        })

        reference.attributes.bindingAttributes.forEach(({ name, value }) => {
            if (name === ':for') {
                const paintForAttributeContents = reference.element.getAttribute(':for')

                const descriptors = extractLoopDescriptors(paintForAttributeContents)

                const targetIterable = evaluateExpression(component, descriptors.arrayExpression)

                const loopHTMLContents = reference.element.innerHTML

                reference.element.innerHTML = ''

                targetIterable.forEach((item) => {
                    const element = document.createElement('div')

                    element.innerHTML = loopHTMLContents

                    const itemContents = [...element.querySelectorAll('*')]

                    const customLoopAttributes = itemContents.map((element) => {
                        const attributes = [...element.attributes]

                        if (attributes.length === 0) return

                        return {
                            element,
                            attributes: getCustomAttributes(attributes)
                        }
                    }).filter(Boolean)

                    const loopItemSetup = { ...component, [descriptors.itemName]: item }

                    customLoopAttributes.forEach(loopNode => {
                        loopNode.attributes.eventAttributes.forEach(({ name, value }) => {
                            loopNode.element.addEventListener(translateEventAttribute(name), evaluateExpression(loopItemSetup, value))
                        })

                        loopNode.attributes.bindingAttributes.forEach(({ name, value }) => {
                            if (name === ':if') {
                                $Flow.queueEffect({
                                    references: uniqueReferences,
                                    effect: () => {
                                        const display = Boolean(evaluateExpression(loopItemSetup, value))

                                        loopNode.element.style.display = display ? 'initial' : 'none'
                                    }
                                })

                                loopNode.element.removeAttribute(':if')

                                return
                            }

                            const isAnTextInput = name === ':value' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'text' || !loopNode.element.hasAttribute('type'))

                            if (isAnTextInput) {
                                $Flow.queueEffect({
                                    references: uniqueReferences,
                                    effect: () => {
                                        loopNode.element.value = evaluateExpression(loopItemSetup, value)
                                    }
                                })

                                loopNode.element.removeAttribute(':value')

                                return
                            }

                            const isAnCheckboxInput = name === ':checked' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'checkbox' || !loopNode.element.hasAttribute('type'))

                            if (isAnCheckboxInput) {
                                $Flow.queueEffect({
                                    references: uniqueReferences,
                                    effect: () => {
                                        const condition = evaluateExpression(loopItemSetup, value)

                                        if (condition) {
                                            loopNode.element.setAttribute('checked', '')
                                        } else {
                                            loopNode.element.removeAttribute('checked')
                                        }
                                    }
                                })

                                reference.element.removeAttribute(name)

                                return
                            }

                            $Flow.queueEffect({
                                references: uniqueReferences,
                                effect: () => {
                                    loopNode.element.setAttribute(translateBindingAttribute(name), evaluateExpression(loopItemSetup, value))
                                    loopNode.element.removeAttribute(name)
                                }
                            })
                        })
                    })

                    const paintForBlocks = [...element.querySelectorAll('Paint')]

                    paintForBlocks.forEach(block => {
                        block['data-flow-paint-expression'] = block.textContent
                    })

                    paintForBlocks.forEach(block => {
                        const expression = block['data-flow-paint-expression']

                        const effect = () => {
                            block.textContent = evaluateExpression(loopItemSetup, expression)
                        }

                        $Flow.queueEffect({
                            references: uniqueReferences,
                            effect
                        })
                    })

                    reference.element.appendChild(element)
                })

                reference.element.removeAttribute(':for')

                return
            }

            const isNotAChildOfLoop = !reference.element['data-flow-looped']

            // This is why paint-for loop has a priority over if
            // loop has to know its HTML before the ifs are evaluated

            if (isNotAChildOfLoop) {
                if (name === ':if') {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            const display = Boolean(evaluateExpression(component, value))

                            reference.element.style.display = display ? 'initial' : 'none'
                        }
                    })

                    reference.element.removeAttribute(name)

                    return
                }

                const isAnTextInput = name === ':value' && reference.element.tagName === 'INPUT' && (reference.element.getAttribute('type') === 'text' || !reference.element.hasAttribute('type'))

                if (isAnTextInput) {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            reference.element.value = evaluateExpression(component, value)
                        }
                    })

                    reference.element.removeAttribute(name)

                    return
                }

                const isAnCheckboxInput = name === ':checked' && reference.element.tagName === 'INPUT' && (reference.element.getAttribute('type') === 'checkbox' || !reference.element.hasAttribute('type'))

                if (isAnCheckboxInput) {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            const condition = evaluateExpression(component, value)

                            if (condition) {
                                reference.element.setAttribute('checked', '')
                            } else {
                                reference.element.removeAttribute('checked')
                            }
                        }
                    })

                    reference.element.removeAttribute(name)

                    return
                }

                $Flow.queueEffect({
                    references: uniqueReferences,
                    effect: () => {
                        reference.element.setAttribute(translateBindingAttribute(name), evaluateExpression(component, value))
                        reference.element.removeAttribute(name)
                    }
                })
            }
        })
    })

    // === LIFECYCLE HOOK onMounted ====
    lifecycleCallbacks.onMounted?.()

    return componentReference
}

export function templateCompiler(componentDefinition, entryPoint = document.body) {
    const component = componentDefinition(entryPoint)

    const componentName = componentDefinition.name

    const nodes = [...entryPoint.querySelectorAll(componentName)]

    nodes.forEach((node) => {
        const componentNode = generateComponent(component, componentName, node)

        mountStyling(component, componentNode)

        node.prepend(componentNode)
    })

    return nodes
}