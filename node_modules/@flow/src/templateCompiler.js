import { evaluateJSExpression } from '../utils/evaluateJSExpression.js'
import { replaceInterpolationMarkers, replaceSelfClosingTags } from '../utils/formatTemplate.js'
import { extractLoopDescriptors } from '../utils/extractLoopDescriptors.js'
import { mountStyling } from '../src/mountStyling.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../src/getTranslatedAttributeNames.js'
import { reactiveVariable, createReactiveArray, generateNewReference } from '../reactivity/reactiveVariable.js'

export function compileTemplate(componentDefinition, componentName, parentNode) {
    const componentNodeReference = document.createElement(`${componentName}-component`) // DOM reference

    const componentNodeId = generateNewReference()

    const lifecycleCallbacks = {}

    const componentContextMethods = {
        emit: (eventName, payload, eventInitDict = { bubbles: true }) => {
            eventInitDict.detail = payload

            const customEvent = new CustomEvent(eventName, eventInitDict)

            componentNodeReference.dispatchEvent(customEvent)
        },
        ref: (value) => {
            return Array.isArray(value) ? createReactiveArray(value, componentNodeId) : reactiveVariable(value, componentNodeId, { isStored: false })
        },
        computed: (value) => {
            return reactiveVariable(value, componentNodeId, { isStored: false })
        },
        useStore: (storeName) => {
            const store = $Flow.useStore(storeName)

            return store
        },
        watch: (reactiveVariable, callback) => {
            const variableReference = reactiveVariable.variableReference

            $Flow.watchSignals[variableReference].push(callback)
        },
        onMounted: (lifecycleCallback) => {
            lifecycleCallbacks.onMounted = lifecycleCallback
        },
        onBeforeMount: (lifecycleCallback) => {
            lifecycleCallbacks.onBeforeMount = lifecycleCallback
        }
    }

    const componentContext = componentDefinition.setup(parentNode.attributes, componentContextMethods)

    // ------------ GETTING REFERENCES ------------
    const references = new Set()

    const reactiveVariables = Object.values(componentContext).filter(value => value?.configuration?.isReactiveVariable)

    reactiveVariables.forEach(reactiveVariable => references.add(reactiveVariable.reference))

    const uniqueReferences = [...references]

    // === LIFECYCLE HOOK onBeforeMount ------------
    lifecycleCallbacks.onBeforeMount?.()

    // ------------ PARSING HTML ------------
    componentNodeReference.innerHTML = replaceSelfClosingTags(replaceInterpolationMarkers(componentContext.template))

    // ------------ BINDING EVENTS AND REACTIVE ATTRIBUTES ------------
    const componentNodeInnerElements = [...componentNodeReference.querySelectorAll('*')]

    const mappedInnerElements = componentNodeInnerElements.map((element) => {
        const attributes = [...element.attributes];

        if (attributes.length === 0) return

        return {
            element,
            attributes: getTranslatedAttributeNames(attributes)
        }
    }).filter(Boolean)

    // ------------ LOOP MARKING STEP ------------
    // Used to distinguish looped elements from the rest
    const loopNodes = [...componentNodeReference.querySelectorAll('Loop')]

    loopNodes.forEach(block => {
        const loopBlockElements = [...block.querySelectorAll('*')]

        loopBlockElements.forEach((loopBlockElement) => {
            loopBlockElement['data-flow-looped'] = true
        })
    })

    // ------------ BINDING AND EVALUATION OF EXPRESSION ELEMENTS + RESTRICTING LOOP ELEMENT ------------
    // Used to bind reactive variables to the DOM that are not part of a loop and evaluate expressions inside {{ }} delimiters
    const standaloneBindingNodes = [...componentNodeReference.querySelectorAll('Paint')].filter(element => !element.closest('Loop'))

    standaloneBindingNodes.forEach(paintNode => {
        paintNode['data-flow-paint-expression'] = paintNode.textContent
    })

    standaloneBindingNodes.forEach(paintNode => {
        const expression = paintNode['data-flow-paint-expression']

        const effect = () => {
            paintNode.textContent = evaluateJSExpression(componentContext, expression)
        }

        $Flow.queueEffect({
            references: uniqueReferences,
            effect
        })
    })

    // ------------ MOUNTING STEP ------------
    mappedInnerElements.forEach((componentInnerNode) => {
        componentInnerNode.attributes.eventAttributes.forEach(({ name: key, value }) => {
            componentInnerNode.element.addEventListener(translateEventAttribute(key), evaluateJSExpression(componentContext, value))
            componentInnerNode.element.removeAttribute(key)
        })

        componentInnerNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
            if (attribute === ':for') {
                const effect = () => {
                    // Extracting the :for attribute content, eg. item in items.
                    const forAttributeContent = componentInnerNode['data-flow-loop-attribute-content'] ??= componentInnerNode.element.getAttribute(':for')

                    // Extracting the array and item name from the :for attribute and array's expression, eg. { arrayExpression: items, itemName: item }.
                    const loopDescriptors = extractLoopDescriptors(forAttributeContent)

                    // Evaluating the array that will be looped, eg. items.
                    const evaluatedTargetArray = evaluateJSExpression(componentContext, loopDescriptors.arrayExpression)

                    // Extracting the HTML template of the looped element, eg. <div>{{ item }}</div>.
                    const loopHTMLItemTemplate = componentInnerNode['data-flow-loop-html-template'] ??= componentInnerNode.element.innerHTML

                    // Resetting the innerHTML of the looped element.
                    componentInnerNode.element.innerHTML = ''

                    // Looping through the array and creating a new element for each item.
                    // copilot please refactor this I think it doesnt have to be this way

                    evaluatedTargetArray.forEach((arrayElement) => {
                        const currentLoopedElement = document.createElement('loop-element')

                        currentLoopedElement.innerHTML = loopHTMLItemTemplate

                        const loopedElementInnerNodes = [...currentLoopedElement.querySelectorAll('*')]

                        const customLoopAttributes = loopedElementInnerNodes.map((element) => {
                            const attributes = [...element.attributes]

                            if (attributes.length === 0) return

                            return {
                                element,
                                attributes: getTranslatedAttributeNames(attributes)
                            }
                        }).filter(Boolean)

                        const loopedElementContext = { ...componentContext, [loopDescriptors.itemName]: arrayElement }

                        customLoopAttributes.forEach(loopNode => {
                            loopNode.attributes.eventAttributes.forEach(({ name: attribute, value }) => {
                                loopNode.element.addEventListener(translateEventAttribute(attribute), evaluateJSExpression(loopedElementContext, value))
                            })

                            loopNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
                                if (attribute === ':if') {
                                    $Flow.queueEffect({
                                        references: uniqueReferences,
                                        effect: () => {
                                            const display = Boolean(evaluateJSExpression(loopedElementContext, value))

                                            loopNode.element.style.display = display ? 'initial' : 'none'
                                        }
                                    })

                                    return
                                }

                                const isNodeATextInput = attribute === ':value' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'text' || !loopNode.element.hasAttribute('type'))

                                if (isNodeATextInput) {
                                    $Flow.queueEffect({
                                        references: uniqueReferences,
                                        effect: () => {
                                            loopNode.element.value = evaluateJSExpression(loopedElementContext, value)
                                        }
                                    })

                                    return
                                }

                                const isNodeACheckboxInput = attribute === ':checked' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'checkbox')

                                if (isNodeACheckboxInput) {
                                    $Flow.queueEffect({
                                        references: uniqueReferences,
                                        effect: () => {
                                            const condition = evaluateJSExpression(loopedElementContext, value)

                                            if (condition) {
                                                loopNode.element.setAttribute('checked', condition)
                                            } else {
                                                loopNode.element.removeAttribute('checked')
                                            }
                                        }
                                    })

                                    return
                                }

                                $Flow.queueEffect({
                                    references: uniqueReferences,
                                    effect: () => {
                                        loopNode.element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(loopedElementContext, value))
                                    }
                                })

                                loopNode.element.removeAttribute(attribute)
                            })
                        })

                        const paintForBlocks = [...currentLoopedElement.querySelectorAll('Paint')]

                        paintForBlocks.forEach(block => {
                            block['data-flow-paint-expression'] = block.textContent
                        })

                        paintForBlocks.forEach(block => {
                            const expression = block['data-flow-paint-expression']

                            const effect = () => {
                                block.textContent = evaluateJSExpression(loopedElementContext, expression)
                            }

                            $Flow.queueEffect({
                                references: uniqueReferences,
                                effect
                            })
                        })

                        componentInnerNode.element.appendChild(currentLoopedElement)
                    })
                }

                $Flow.queueEffect({
                    references: uniqueReferences,
                    effect
                })

                componentInnerNode.element.removeAttribute(attribute)

                return
            }

            const isNodeNotAChildOfLoopElement = !componentInnerNode.element['data-flow-looped']

            if (isNodeNotAChildOfLoopElement) {
                if (attribute === ':if') {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            const display = Boolean(evaluateJSExpression(componentContext, value))

                            componentInnerNode.element.style.display = display ? 'initial' : 'none'
                        }
                    })

                    return
                }


                const isNodeATextInput = attribute === ':value' && componentInnerNode.element.tagName === 'INPUT' && (componentInnerNode.element.getAttribute('type') === 'text' || !componentInnerNode.element.hasAttribute('type'))

                if (isNodeATextInput) {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            componentInnerNode.element.value = evaluateJSExpression(componentContext, value)
                        }
                    })

                    return
                }

                const isNodeACheckboxInput = attribute === ':checked' && componentInnerNode.element.tagName === 'INPUT' && componentInnerNode.element.getAttribute('type') === 'checkbox';

                if (isNodeACheckboxInput) {
                    $Flow.queueEffect({
                        references: uniqueReferences,
                        effect: () => {
                            const condition = evaluateJSExpression(componentContext, value)

                            if (condition) {
                                componentInnerNode.element.setAttribute('checked', condition)
                            } else {
                                componentInnerNode.element.removeAttribute('checked')
                            }
                        }
                    })

                    return
                }

                $Flow.queueEffect({
                    references: uniqueReferences,
                    effect: () => {
                        componentInnerNode.element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(componentContext, value))
                    }
                })

                componentInnerNode.element.removeAttribute(attribute)
            }
        })
    })

    // ------------ LIFECYCLE HOOK onMounted ------------
    lifecycleCallbacks.onMounted?.()

    return componentNodeReference
}

export function templateCompiler(componentFunction, entryPoint = document.body) {
    // Extracting the component definition from the function that defines it, eg. export const Counter = () => ...
    const component = componentFunction()

    // Extracting the component name from the function that defines it, eg. export const Counter = () => ...
    const componentName = componentFunction.name

    // Selecting all component nodes that are defined inside the entryPoint, eg. <Counter></Counter>.
    const nodes = [...entryPoint.querySelectorAll(componentName)]

    // Mounting the component to the entryPoint, eg. <Counter></Counter>
    nodes.forEach((componentEntryPoint) => {
        const componentNode = compileTemplate(component, componentName, componentEntryPoint)

        mountStyling(component, componentNode)

        componentEntryPoint.prepend(componentNode)
    })

    return nodes
}