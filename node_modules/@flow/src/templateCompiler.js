import { evaluateJSExpression } from '../utils/evaluateJSExpression.js'
import { replaceInterpolationMarkers } from '../utils/formatTemplate.js'
import { extractLoopDescriptors } from '../utils/extractLoopDescriptors.js'
import { getExpressionDependencies } from '../utils/getExpressionDependencies.js'
import { determineUsedComponents } from '../utils/determineUsedComponents.js'
import { mountStyling } from '../src/mountStyling.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../utils/getTranslatedAttributeNames.js'
import { reactiveVariable, createReactiveArray, generateNewReference } from '../reactivity/reactiveVariable.js'

const REACTIVE_VARIABLE_REF_CONFIG = {
    isStored: false,
    isRef: true,
    isComputed: false,
    isProp: false,

    influences: []
}
const REACTIVE_VARIABLE_COMPUTED_CONFIG = {
    isStored: false,
    isRef: false,
    isComputed: true,
    isProp: false,

    influences: [],
    dependsOn: []
}
const REACTIVE_VARIABLE_PROP_CONFIG = {
    isStored: false,
    isRef: false,
    isComputed: false,
    isProp: true,

    influences: []
}

export function compileTemplate(componentFunction, componentParentNode, parentContext = {}) {
    const componentNodeId = generateNewReference('component')

    componentParentNode.$FlowElement = {}

    $FlowEngine.componentNodes[componentNodeId] = componentParentNode

    const lifecycleCallbacks = {
        onMounted: undefined,
        onBeforeMount: undefined
    }

    // ------------ PROPS BINDING ------------
    let componentProps = $FlowEngine.props[componentParentNode.tagName] || [] //  - in case the parent node's tagName is 'DIV'.

    const props = componentParentNode.$FlowElement.props = {}

    componentProps.forEach((propName) => {
        const attributeOriginalContent = componentParentNode.getAttribute(`data-flow-attribute-original-content-of-${propName}`)

        const propValue = evaluateJSExpression(parentContext, attributeOriginalContent)

        const prop = props[propName] = reactiveVariable(propValue, structuredClone(REACTIVE_VARIABLE_PROP_CONFIG))

        const dependencies = getExpressionDependencies(attributeOriginalContent)
        const propReferences = []

        Object.entries(parentContext).forEach(([key, value]) => {
            if (value.configuration?.isReactiveVariable && dependencies?.includes(key)) {
                propReferences.push(value.variableReference)
            }
        })

        $FlowEngine.queueEffect({
            references: propReferences,
            effect: () => {
                prop.value = evaluateJSExpression(parentContext, attributeOriginalContent)
            }
        })
    })

    // ------------ DEFINING CONTEXT METHODS ------------
    const componentContextMethods = {
        emit: (eventName, payload, eventInitDict = { bubbles: true }) => {
            eventInitDict.detail = payload

            const customEvent = new CustomEvent(eventName, eventInitDict)

            componentParentNode.dispatchEvent(customEvent)
        },
        ref: (value) => {
            return reactiveVariable(value, structuredClone(REACTIVE_VARIABLE_REF_CONFIG))
        },
        computed: (callback) => {
            return reactiveVariable(callback, structuredClone(REACTIVE_VARIABLE_COMPUTED_CONFIG))
        },
        useStore: (storeName) => {
            const store = $FlowEngine.useStore(storeName)

            return store
        },
        watch: (source, callback, configuration) => {
            const isRef = source.configuration?.isRef
            const isComputed = source.configuration?.isComputed
            const isProp = source.configuration?.isProp

            if (isRef || isComputed || isProp) {
                const variableReference = source.variableReference

                if (configuration?.immediate) {
                    // TODO: is it right? that immediate watcher's both new and old value are the same?
                    callback(source.value, source.value)
                }

                $FlowEngine.watchCallbacks[variableReference].push(callback)
            }
        },
        onMounted: (callback) => {
            lifecycleCallbacks.onMounted = callback
        },
        onBeforeMount: (callback) => {
            lifecycleCallbacks.onBeforeMount = callback
        },
        props: componentParentNode.$FlowElement.props
    }

    const componentContext = componentFunction(componentContextMethods)

    // ------------ LIFECYCLE HOOK onBeforeMount ------------
    lifecycleCallbacks.onBeforeMount?.()

    // ------------ PARSING HTML ------------
    componentParentNode.innerHTML = replaceInterpolationMarkers(componentContext.template)

    // ------------ BINDING EVENTS AND REACTIVE ATTRIBUTES ------------
    const componentNodeInnerElements = [...componentParentNode.querySelectorAll('*')]

    const mappedInnerElements = componentNodeInnerElements.map((element) => {
        const attributes = [...element.attributes];

        if (attributes.length === 0) return

        return {
            element,
            attributes: getTranslatedAttributeNames(attributes)
        }
    }).filter(Boolean)

    // ------------ LOOP MARKING STEP ------------
    // Used to distinguish looped elements from the rest
    const loopNodes = [...componentParentNode.querySelectorAll('Loop')]

    loopNodes.forEach(block => {
        const loopBlockElements = [...block.querySelectorAll('*')]

        loopBlockElements.forEach((loopBlockElement) => {
            loopBlockElement['data-flow-looped'] = true
        })
    })

    // ------------ DETERMINING USED COMPONENTS ------------
    const componentNamesUsed = determineUsedComponents(componentContext.template).map(componentName => componentName.toUpperCase())

    // ------------ MOUNTING STEP ------------
    mappedInnerElements.forEach((componentInnerNode) => {
        if (componentInnerNode.element.tagName === 'PAINT') return

        componentInnerNode.attributes.eventAttributes.forEach(({ name: key, value }) => {
            componentInnerNode.element.addEventListener(translateEventAttribute(key), evaluateJSExpression(componentContext, value))
            componentInnerNode.element.removeAttribute(key)
        })

        componentInnerNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
            componentInnerNode.element.setAttribute(`data-flow-attribute-original-content-${translateBindingAttribute(attribute)}`, value)

            // Note: for loop is mounted separately from other elements and has its own mounting (copied) step.
            if (attribute === ':for') {
                const effect = () => {
                    // Extracting the :for attribute content, eg. item in items.
                    const forAttributeContent = componentInnerNode['data-flow-loop-attribute-content'] ??= componentInnerNode.element.getAttribute(':for')

                    // Extracting the array and item name from the :for attribute and array's expression, eg. { arrayExpression: items, itemName: item }.
                    const loopDescriptors = extractLoopDescriptors(forAttributeContent)

                    // Evaluating the array that will be looped, eg. items.
                    const evaluatedTargetArray = evaluateJSExpression(componentContext, loopDescriptors.arrayExpression)

                    // Extracting the HTML template of the looped element, eg. <div>{{ item }}</div>.
                    const loopHTMLItemTemplate = componentInnerNode['data-flow-loop-inner-html'] ??= componentInnerNode.element.innerHTML

                    // Resetting the innerHTML of the looped element.
                    componentInnerNode.element.innerHTML = ''

                    // Looping through the array and creating a new element for each item.
                    evaluatedTargetArray.forEach((arrayElement) => {
                        const currentLoopedElement = document.createElement('looped-element')

                        currentLoopedElement.innerHTML = loopHTMLItemTemplate

                        const loopedElementInnerNodes = [...currentLoopedElement.querySelectorAll('*')]

                        const customLoopAttributes = loopedElementInnerNodes.map((element) => {
                            const attributes = [...element.attributes]

                            if (attributes.length === 0) return

                            return {
                                element,
                                attributes: getTranslatedAttributeNames(attributes)
                            }
                        }).filter(Boolean)

                        const loopedElementContext = { ...componentContext, [loopDescriptors.itemName]: arrayElement }

                        customLoopAttributes.forEach(loopNode => {
                            loopNode.attributes.eventAttributes.forEach(({ name: attribute, value }) => {
                                loopNode.element.addEventListener(translateEventAttribute(attribute), () => {
                                    evaluateJSExpression(loopedElementContext, value)
                                })
                            })

                            loopNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
                                const dependencies = getExpressionDependencies(value)
                                const attributeReferences = []

                                Object.entries(loopedElementContext).forEach(([key, value]) => {
                                    if (value.configuration?.isReactiveVariable && dependencies.includes(key)) {
                                        attributeReferences.push(value.variableReference)
                                    }
                                })

                                loopNode.element.removeAttribute(attribute)

                                if (attribute === ':if') {
                                    $FlowEngine.queueEffect({
                                        references: attributeReferences,
                                        effect: () => {
                                            const display = Boolean(evaluateJSExpression(loopedElementContext, value))

                                            loopNode.element.style.display = display ? 'initial' : 'none'
                                        }
                                    })

                                    return
                                }

                                const isNodeATextInput = attribute === ':value' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'text' || !loopNode.element.hasAttribute('type'))

                                if (isNodeATextInput) {
                                    $FlowEngine.queueEffect({
                                        references: attributeReferences,
                                        effect: () => {
                                            loopNode.element.value = evaluateJSExpression(loopedElementContext, value)
                                        }
                                    })

                                    return
                                }

                                const isNodeACheckboxInput = attribute === ':checked' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'checkbox')

                                if (isNodeACheckboxInput) {
                                    $FlowEngine.queueEffect({
                                        references: attributeReferences,
                                        effect: () => {
                                            const condition = evaluateJSExpression(loopedElementContext, value)

                                            if (condition) {
                                                loopNode.element.setAttribute('checked', condition)
                                            } else {
                                                loopNode.element.removeAttribute('checked')
                                            }
                                        }
                                    })

                                    return
                                }

                                $FlowEngine.queueEffect({
                                    references: attributeReferences,
                                    effect: () => {
                                        loopNode.element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(loopedElementContext, value))
                                    }
                                })
                            })
                        })

                        const paintForBlocks = [...currentLoopedElement.querySelectorAll('flow-paint')]

                        paintForBlocks.forEach(paintNode => {
                            const expression = paintNode['data-flow-paint-expression'] ??= paintNode.textContent
                            const dependencies = getExpressionDependencies(paintNode.textContent)

                            const paintNodeReferences = []

                            Object.entries(loopedElementContext).forEach(([key, value]) => {
                                if (value.configuration?.isReactiveVariable && dependencies.includes(key)) {
                                    paintNodeReferences.push(value.variableReference)
                                }
                            })

                            const textNode = document.createTextNode('')

                            paintNode.parentNode.insertBefore(textNode, paintNode)
                            paintNode.parentNode.removeChild(paintNode)

                            const effect = () => {
                                textNode.textContent = evaluateJSExpression(loopedElementContext, expression)
                            }

                            $FlowEngine.queueEffect({
                                references: paintNodeReferences,
                                effect
                            })
                        })

                        componentInnerNode.element.append(...currentLoopedElement.childNodes)
                    })
                }

                $FlowEngine.queueEffect({
                    references: [componentNodeId],
                    effect
                })

                componentInnerNode.element.removeAttribute(attribute)

                return
            }

            const isNodeNotAChildOfLoopElement = !componentInnerNode.element['data-flow-looped']

            componentInnerNode.element.removeAttribute(attribute)

            // ---- EVALUTING ATTRIBUTE'S REACTIVE DEPENDENCIES ----
            const dependencies = getExpressionDependencies(value)
            const attributeReferences = []

            Object.entries(componentContext).forEach(([key, value]) => {
                if (value.configuration?.isReactiveVariable && dependencies?.includes(key)) {
                    attributeReferences.push(value.variableReference)
                }
            })

            // ---- MOUNTING :if DIRECTIVE ----
            if (isNodeNotAChildOfLoopElement) {
                if (attribute === ':if') {
                    $FlowEngine.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            const display = Boolean(evaluateJSExpression(componentContext, value))

                            componentInnerNode.element.style.display = display ? 'initial' : 'none'
                        }
                    })

                    return
                }

                // ---- MOUNTING INPUT ELEMENTS ----
                const isNodeATextInput = attribute === ':value' && componentInnerNode.element.tagName === 'INPUT' && (componentInnerNode.element.getAttribute('type') === 'text' || !componentInnerNode.element.hasAttribute('type'))

                if (isNodeATextInput) {
                    $FlowEngine.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            componentInnerNode.element.value = evaluateJSExpression(componentContext, value)
                        }
                    })

                    return
                }

                const isNodeACheckboxInput = attribute === ':checked' && componentInnerNode.element.tagName === 'INPUT' && componentInnerNode.element.getAttribute('type') === 'checkbox';

                if (isNodeACheckboxInput) {
                    $FlowEngine.queueEffect({
                        references: attributeReferences,
                        effect: () => {
                            const condition = evaluateJSExpression(componentContext, value)

                            if (condition) {
                                componentInnerNode.element.setAttribute('checked', condition)
                            } else {
                                componentInnerNode.element.removeAttribute('checked')
                            }
                        }
                    })

                    return
                }

                // ---- MOUNTING ANY OTHER ATTRIBUTE ----
                $FlowEngine.queueEffect({
                    references: attributeReferences,
                    effect: () => {
                        componentInnerNode.element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(componentContext, value))
                    }
                })
            }
        })
    })

    // ------------ BINDING AND EVALUATION OF EXPRESSION ELEMENTS + RESTRICTING LOOP ELEMENT ------------
    // Used to bind reactive variables to the DOM that are not part of a loop and evaluate expressions inside {{ }} delimiters
    const standaloneBindingNodes = [...componentParentNode.querySelectorAll('flow-paint')].filter(element => !element.closest('Loop'))

    standaloneBindingNodes.forEach(paintNode => {
        const expression = paintNode['data-flow-paint-expression'] ??= paintNode.textContent
        const dependencies = paintNode['data-flow-paint-expression-dependencies'] ??= getExpressionDependencies(paintNode.textContent)

        const paintNodeReferences = []

        Object.entries(componentContext).forEach(([key, value]) => {
            if (value.configuration?.isReactiveVariable && dependencies?.includes(key)) {
                paintNodeReferences.push(value.variableReference)
            }
        })

        const textNode = document.createTextNode('')

        paintNode.parentNode.insertBefore(textNode, paintNode)
        paintNode.parentNode.removeChild(paintNode)

        const effect = () => {
            textNode.textContent = evaluateJSExpression(componentContext, expression)
        }

        $FlowEngine.queueEffect({
            references: paintNodeReferences,
            effect
        })
    })

    // ------------ LIFECYCLE HOOK onMounted ------------
    lifecycleCallbacks.onMounted?.()

    mountStyling(componentContext.style, componentParentNode)

    return { componentNodeReference: componentParentNode, componentNamesUsed, parentContext: componentContext }
}

export function templateCompiler(componentFunction, lookUpNode, defaultEntryPointId, previousParentContext) {
    let componentNodes = []

    const componentName = componentFunction.name.toUpperCase()

    if (lookUpNode === document.body && defaultEntryPointId) {
        componentNodes = [...lookUpNode.querySelectorAll(defaultEntryPointId)]
    } else {
        componentNodes = [...lookUpNode.querySelectorAll(`${componentName}:not([data-flow-compiled-component])`)];
    }

    componentNodes.forEach((componentParentNode) => {
        const { componentNodeReference, componentNamesUsed, parentContext } = compileTemplate(componentFunction, componentParentNode, previousParentContext)

        if (componentNamesUsed.includes(componentName)) {
            throw new Error(`Component "${componentName}" tries to render itself (Recursive components are due to be supported).`)
        }

        componentParentNode.prepend(...componentNodeReference.childNodes)

        componentParentNode.setAttribute('data-flow-compiled-component', true);

        componentNamesUsed.forEach(componentName => {
            if (!$FlowEngine.components[componentName]) return

            const componentModule = $FlowEngine.components[componentName]

            templateCompiler(componentModule.componentFunction, componentParentNode, null, parentContext)

            componentModule.meta.timesUsed += 1
        });
    })
}