import { evaluateJSExpression } from "../../utils/evaluateJSExpression.js";
import { camelToKebabCase } from "../../utils/camelToKebabCase.js";
import { replaceInterpolationMarkers } from "../../utils/formatTemplate.js";
import { bindForDirective } from "./../compiler/directives/for.js";
import { bindIfDirective } from "./../compiler/directives/if.js";
import { mountStyling } from "../../src/compiler/mountStyling.js";
import {
    getTranslatedAttributeNames,
    translateBindingAttribute,
    translateEventAttribute,
} from "../../utils/getTranslatedAttributeNames.js";
import {
    reactiveArray,
    reactiveVariable,
} from "../../reactivity/reactiveVariable.js";
import {
    REACTIVE_VARIABLE_REF_CONFIG,
    REACTIVE_VARIABLE_COMPUTED_CONFIG,
    REACTIVE_VARIABLE_PROP_CONFIG,
    REACTIVE_VARIABLE_ARRAY_CONFIG,
    LIFECYCLE_CALLBACKS_TEMPLATE,
    STANDARD_INPUT_TYPES,
    INPUT_TYPES_WITH_CHECKED_ATTRIBUTE,
} from "../../configuration/configuration.js";

const compilerMacros = {
    ref: (value) => {
        if (Array.isArray(value)) {
            value.forEach((element, index) => {
                value[index] = reactiveVariable(
                    element,
                    structuredClone(REACTIVE_VARIABLE_REF_CONFIG)
                );
            });

            const outputReactiveArray = reactiveArray(
                value,
                structuredClone(REACTIVE_VARIABLE_ARRAY_CONFIG)
            );

            return outputReactiveArray;
        }

        return reactiveVariable(
            value,
            structuredClone(REACTIVE_VARIABLE_REF_CONFIG)
        );
    },
    computed: (callback) => {
        return reactiveVariable(
            callback,
            structuredClone(REACTIVE_VARIABLE_COMPUTED_CONFIG)
        );
    },
    watch: (source, callback, watchConfiguration = {}) => {
        const isSourceAFunction = typeof source === "function";
        const isSourceAnArray = Array.isArray(source);

        const { immediate = false } = watchConfiguration;

        const setWatchCallback = (sourceElement) => {
            $VindEngine.dependencyExtractorRunning = true;

            const callbackValue = sourceElement();

            if ($VindEngine.extractedDependencies.size > 0) {
                const extractedDependencies = Array.from(
                    $VindEngine.extractedDependencies
                );

                if (extractedDependencies.length > 0) {
                    const [firstReferencedReference] = extractedDependencies;

                    if (!firstReferencedReference) return;

                    extractedDependencies.forEach((extractedDependency) => {
                        $VindEngine.watchCallbacks[extractedDependency].push(callback);
                    });
                }

                $VindEngine.extractedDependencies.clear();
            }

            $VindEngine.dependencyExtractorRunning = false;

            return callbackValue;
        };

        if (isSourceAFunction) {
            const callbackValue = setWatchCallback(source);

            if (immediate) {
                callback(callbackValue, callbackValue);
            }

            return;
        }

        if (isSourceAnArray) {
            source.forEach((sourceFunction) => {
                setWatchCallback(sourceFunction);
            });

            return;
        }
    },
};

export function compileComponent(
    componentFunction,
    componentParentElement,
    parentContext = {},
    componentName,
    configuration = {}
) {
    if (!componentFunction) throw new Error("Component function is not defined.");
    if (!componentParentElement)
        throw new Error("Component parent element is not defined.");
    if (!componentName) throw new Error("Component name is not defined.");

    componentParentElement.$VindComponent ??= {};
    componentParentElement.$VindComponent.properties ??= {};

    const upperCaseComponentName = componentName.toUpperCase();

    const lifecycleCallbacks = structuredClone(LIFECYCLE_CALLBACKS_TEMPLATE);
    const properties = componentParentElement.$VindComponent.properties;

    // * Defining component's destructurable properties.
    const componentInternalContext = {
        ...compilerMacros,
        onMounted: (callback) => {
            lifecycleCallbacks.onMounted = callback;
        },
        onBeforeMount: (callback) => {
            lifecycleCallbacks.onBeforeMount = callback;
        },
        $emit: (eventName, payload, eventInitDict = { bubbles: true }) => {
            eventInitDict.detail = payload;

            const customEvent = new CustomEvent(eventName, eventInitDict);

            componentParentElement.dispatchEvent(customEvent);
        },
        $stores: $VindEngine.stores,
        $router: $VindEngine.stores.routerStore,
        $props: componentParentElement.$VindComponent.properties,
    };

    // * Binding props and transforming them into reactive variables.
    let componentProperties =
        $VindEngine.propertiesByComponent[componentParentElement.tagName] || []; // *  - in case the parent element's tagName is 'DIV'.

    Object.entries(componentProperties).forEach(
        ([propertyKey, propertyConfiguration]) => {
            const kebabCasedPropertyKey = camelToKebabCase(propertyKey);

            const attributeExpression = componentParentElement.getAttribute(
                `data-vind-origin-of-${kebabCasedPropertyKey}`
            );

            const propertyReactiveVariable = reactiveVariable(
                undefined,
                structuredClone(REACTIVE_VARIABLE_PROP_CONFIG)
            );

            properties[propertyKey] = propertyReactiveVariable;

            $VindEngine.queueReactiveEffect({
                effect: () => {
                    const evaluatedJSExpression = evaluateJSExpression(
                        parentContext,
                        attributeExpression
                    );

                    if (
                        evaluatedJSExpression === null &&
                        (propertyConfiguration.required ||
                            typeof propertyConfiguration.required === "undefined")
                    ) {
                        console.warn(
                            `Property "${propertyKey}" of component "${componentName}" is required but is either unused or null.`
                        );
                    }

                    if (
                        evaluatedJSExpression !== null &&
                        typeof evaluatedJSExpression !== propertyConfiguration.type
                    ) {
                        console.warn(
                            `Type of passed "${propertyKey}" property does not match the type defined in its configuration. Expetected "${propertyConfiguration.type
                            }" but got "${typeof evaluatedJSExpression}" instead.`
                        );
                    }

                    propertyReactiveVariable.value =
                        evaluatedJSExpression ||
                        propertyConfiguration?.default ||
                        evaluatedJSExpression;
                },
            });

            if ("default" in propertyConfiguration) {
                delete propertyConfiguration.default;
            }
        }
    );

    // * Calling a component function with the context methods. The component function returns a context object.
    // * It is fine to think of it as Vue's onCreated lifecycle hook.
    const stringifiedComponentFunction = componentFunction.toString();

    const evaluatedComponentFunction = evaluateJSExpression(
        componentInternalContext,
        stringifiedComponentFunction
    );

    const componentContext = Object.assign(
        properties,
        evaluatedComponentFunction()
    );

    // * Setting properties on componentContext that can be later referenced in templates by preprending them with '$' sign.
    componentContext.$path = $VindEngine.stores.routerStore.path;
    componentContext.$emit = (eventName) => () =>
        componentInternalContext.$emit(eventName);

    // * Setting componentParentElement's innerHTML to the component's template and removing the 'template' property.
    const componentTemplate =
        $VindEngine.templateByComponent[upperCaseComponentName] || "";

    // * Invoking onBeforeMount lifecycle hook if defined.
    lifecycleCallbacks.onBeforeMount?.();

    // * ! After running this instruction component gets its HTML content set.
    componentParentElement.innerHTML =
        replaceInterpolationMarkers(componentTemplate);

    const componentStyle =
        $VindEngine.styleByComponent[upperCaseComponentName] || "";

    // * Grabbing all inner elements of the componentParentElement that has just been created by innerHTML property.
    let componentInnerElements = [
        ...componentParentElement.querySelectorAll(
            "*:not([data-vind-compiled-component])"
        ),
    ];

    // * Filtering out elements of nested loops.
    componentInnerElements = componentInnerElements.filter((element) => {
        // * This is so-called "loop-marking". It is used to distinguish looped elements from the rest.
        // * This because loops are mounted separately from the rest of the component.

        if (element.tagName === "LOOP") {
            const loopBlockElements = [...element.querySelectorAll("*")];

            loopBlockElements.forEach((loopBlockElement) => {
                loopBlockElement.setAttribute("data-vind-looped-element", true);
            });
        }

        // * Find the closest 'loop' element
        const closestLoopElement = element.closest("loop");

        // * If no 'loop' element is found, keep the element
        if (!closestLoopElement) return true;

        // * If the closest 'loop' element has a parent that is also a 'loop', filter it out
        return !closestLoopElement.parentElement.closest("loop");
    });

    // * Formatting every inner element in order for easier manipulation.
    let mappedElements = componentInnerElements.map((element) => {
        const attributes = [...element.attributes];

        return {
            element,
            attributes: getTranslatedAttributeNames(attributes),
        };
    });

    // * Determining component drawers.
    const drawerElements = [...componentParentElement.querySelectorAll("Drawer")];
    const mappedInnerDrawerTags = drawerElements.map((drawerElement) => {
        const drawerName = drawerElement.getAttribute("name");

        const targetInsertTag =
            componentParentElement.$VindComponent?.mappedInnerInsertTags?.find(
                (insertTag) => insertTag.name === drawerName
            );

        if (targetInsertTag) {
            drawerElement.prepend(targetInsertTag.insertElement);
        }

        return {
            element: drawerElement,
            name: drawerElement.getAttribute("name"),
        };
    });

    componentParentElement.$VindComponent.mappedInnerDrawerTags =
        mappedInnerDrawerTags;

    const componentNamesUsed = new Set();

    // * The famous "mounting" step. This is where the magic happens.
    mappedElements.forEach((mappedElement) => {
        const element = mappedElement.element;

        const componentModule = $VindEngine.componentModules[element.tagName];

        // * insertTags
        if (componentModule) {
            componentNamesUsed.add(element.tagName);

            element.$VindComponent = {};

            const insertTags = [...element.querySelectorAll("Insert")];
            const mappedInnerInsertTags = insertTags.map((insertElement) => {
                return {
                    insertElement,
                    name: insertElement.getAttribute("name"),
                };
            });

            element.$VindComponent.mappedInnerInsertTags = mappedInnerInsertTags;
        }

        // * eventAttributes
        // * Mounting event attributes that start with '@' character.
        mappedElement.attributes.eventAttributes.forEach(
            ({ name: eventBindingAttribute, value }) => {
                const evaluatedCallaback = (event) =>
                    evaluateJSExpression(componentContext, value)?.(event);

                element.addEventListener(
                    translateEventAttribute(eventBindingAttribute),
                    evaluatedCallaback
                );
            }
        );

        // * bindingAttributes
        // * Mounting binding attributes that start with ':' character.
        mappedElement.attributes.bindingAttributes.forEach(
            ({ name: bindingAttribute, value }) => {
                const translatedBindingAttribute =
                    translateBindingAttribute(bindingAttribute);

                element.setAttribute(
                    `data-vind-origin-of-${translatedBindingAttribute}`,
                    value
                );

                // * Note: for loop is mounted separately from other elements and has its own mounting (copied) step.
                if (bindingAttribute === ":for") {
                    bindForDirective(mappedElement, componentContext);

                    return;
                }

                const isElementNotAChildOfLoopElement = !element.getAttribute(
                    "data-vind-looped-element"
                );

                // * Mounting :if directive.
                if (isElementNotAChildOfLoopElement) {
                    if (bindingAttribute === ":if") {
                        bindIfDirective(element, componentContext);

                        return;
                    }

                    // * Mounting input elements' value and checked attributes.
                    const isAnInputElement = element.tagName === "INPUT";

                    const inputType = element.getAttribute("type") || "text";

                    if (isAnInputElement && bindingAttribute === ":model") {
                        const isStandardInputType =
                            STANDARD_INPUT_TYPES.includes(inputType);

                        const isInputTypeWithCheckedAttribute =
                            INPUT_TYPES_WITH_CHECKED_ATTRIBUTE.includes(inputType);

                        if (value) {
                            let proxy = undefined;

                            const isModelAttributeNested = value.includes(".");

                            if (isModelAttributeNested) {
                                const objectTokens = value.split(".");

                                const lastProperty = objectTokens.at(-1);

                                const modelObject = objectTokens.slice(0, -1).join(".");

                                proxy = evaluateJSExpression(componentContext, modelObject);

                                if (isStandardInputType) {
                                    element.addEventListener("input", (event) => {
                                        proxy[lastProperty] = event.target.value;
                                    });
                                } else if (isInputTypeWithCheckedAttribute) {
                                    element.addEventListener("input", (event) => {
                                        proxy[lastProperty] = event.target.checked;
                                    });
                                }
                            }

                            if (!isModelAttributeNested) {
                                proxy = evaluateJSExpression(componentContext, value);

                                if (isStandardInputType) {
                                    element.addEventListener("input", (event) => {
                                        proxy.value = event.target.value;
                                    });
                                } else if (isInputTypeWithCheckedAttribute) {
                                    element.addEventListener("input", (event) => {
                                        proxy.value = event.target.checked;
                                    });
                                }
                            }

                            let expression = isModelAttributeNested
                                ? value
                                : `${value}.value`;

                            if (isStandardInputType) {
                                $VindEngine.queueReactiveEffect({
                                    effect: () => {
                                        const evaluatedExpression = evaluateJSExpression(
                                            componentContext,
                                            expression
                                        );

                                        element.setAttribute("value", evaluatedExpression);

                                        element.value = evaluatedExpression;
                                    },
                                });

                                return;
                            }

                            if (isInputTypeWithCheckedAttribute) {
                                $VindEngine.queueReactiveEffect({
                                    effect: () => {
                                        const condition = evaluateJSExpression(
                                            componentContext,
                                            expression
                                        );

                                        if (condition) {
                                            element.setAttribute("checked", condition);
                                        } else {
                                            element.removeAttribute("checked");
                                        }

                                        element.checked = condition;
                                    },
                                });

                                return;
                            }
                        }
                    }

                    if (isAnInputElement && bindingAttribute === ":value") {
                        if (STANDARD_INPUT_TYPES.includes(inputType)) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const evaluatedExpression = evaluateJSExpression(
                                        componentContext,
                                        value
                                    );

                                    element.setAttribute("value", evaluatedExpression);

                                    element.value = evaluatedExpression;
                                },
                            });

                            return;
                        }
                    }

                    if (isAnInputElement && bindingAttribute === ":checked") {
                        if (INPUT_TYPES_WITH_CHECKED_ATTRIBUTE.includes(inputType)) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const condition = evaluateJSExpression(
                                        componentContext,
                                        value
                                    );

                                    if (condition) {
                                        element.setAttribute("checked", condition);
                                    } else {
                                        element.removeAttribute("checked");
                                    }

                                    element.checked = condition;
                                },
                            });

                            return;
                        }
                    }

                    // * Mounting any other attribute that is not a directive.
                    $VindEngine.queueReactiveEffect({
                        effect: () => {
                            const evaluatedExpression = evaluateJSExpression(
                                componentContext,
                                value
                            );

                            element.setAttribute(
                                translatedBindingAttribute,
                                evaluatedExpression
                            );
                        },
                    });
                }
            }
        );
    });

    // * This is used to bind reactive variables to the DOM that are not part of a loop and evaluate expressions inside {{ }} delimiters
    let interpolationElements = undefined;

    const { target } = configuration;

    if (typeof target === "undefined" || target === "general") {
        interpolationElements = [
            ...componentParentElement.querySelectorAll("vind-expression"),
        ].filter((element) => !element.closest("Loop"));
    } else if (target === "loop") {
        interpolationElements = [
            ...componentParentElement.querySelectorAll("vind-expression"),
        ];
    }

    interpolationElements.forEach((interpolationElement) => {
        const expression = interpolationElement.textContent;

        const textNode = document.createTextNode("");

        interpolationElement.parentNode.insertBefore(
            textNode,
            interpolationElement
        );
        interpolationElement.parentNode.removeChild(interpolationElement);

        $VindEngine.queueReactiveEffect({
            effect: () => {
                textNode.textContent = evaluateJSExpression(
                    componentContext,
                    expression
                );
            },
        });
    });

    // * Calling the onMounted lifecycle callback if it exists

    if (!$VindEngine.componentsWithStyleMounted.has(upperCaseComponentName)) {
        mountStyling(componentStyle, upperCaseComponentName);

        $VindEngine.componentsWithStyleMounted.add(upperCaseComponentName);
    }

    lifecycleCallbacks.onMounted?.();

    return {
        componentParentElement,
        componentNamesUsed,
        nextParentContext: componentContext,
    };
}

export function templateCompiler(
    componentFunction,
    loopUpElement,
    parentContext,
    parentComponentName,
    configuration = {}
) {
    let componentElements = [];
    let foundElements = [];

    const { defaultEntryPointId, target = "general" } = configuration;

    if (defaultEntryPointId) {
        foundElements = loopUpElement.querySelectorAll(defaultEntryPointId);

        delete configuration.defaultEntryPointId;
    } else if (parentComponentName) {
        foundElements = loopUpElement.querySelectorAll(
            `${parentComponentName}:not([data-vind-compiled-component])`
        );
    } else {
        throw new Error("Parent component name is required.");
    }

    componentElements = Array.from(foundElements);

    componentElements.forEach((componentElement) => {
        const { componentParentElement, componentNamesUsed, nextParentContext } =
            compileComponent(
                componentFunction,
                componentElement,
                parentContext,
                parentComponentName,
                { target }
            );

        if (componentNamesUsed.has(parentComponentName)) {
            throw new Error(
                `Component "${parentComponentName}" is referenced inside its body.`
            );
        }

        componentElement.setAttribute("data-vind-compiled-component", true);

        componentElement.prepend(...componentParentElement.childNodes);

        const uniqueComponentNamesUsed = Array.from(componentNamesUsed);

        uniqueComponentNamesUsed.forEach((usedComponentName) => {
            const componentModule = $VindEngine.componentModules[usedComponentName];

            const { componentFunction, componentName: nextComponentName } =
                componentModule;

            templateCompiler(
                componentFunction,
                componentElement,
                nextParentContext,
                nextComponentName,
                configuration
            );
        });
    });
}
