import { evaluateJSExpression } from '../../utils/evaluateJSExpression.js'
import { camelToKebabCase } from '../../utils/camelToKebabCase.js'
import { replaceInterpolationMarkers } from '../../utils/formatTemplate.js'
import { bindForDirective } from './../compiler/directives/for.js'
import { bindIfDirective } from './../compiler/directives/if.js'
import { mountStyling } from '../../src/compiler/mountStyling.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../../utils/getTranslatedAttributeNames.js'
import { reactiveArray, reactiveVariable } from '../../reactivity/reactiveVariable.js'
import {
    REACTIVE_VARIABLE_REF_CONFIG,
    REACTIVE_VARIABLE_COMPUTED_CONFIG,
    REACTIVE_VARIABLE_PROP_CONFIG,
    REACTIVE_VARIABLE_ARRAY_CONFIG,
    LIFECYCLE_CALLBACKS_TEMPLATE,
    STANDARD_INPUT_TYPES,
    INPUT_TYPES_WITH_CHECKED_ATTRIBUTE
} from '../../configuration/configuration.js'

const compilerMacros = {
    ref: (value) => {
        if (Array.isArray(value)) {
            value.forEach((element, index) => {
                value[index] = reactiveVariable(element, structuredClone(REACTIVE_VARIABLE_REF_CONFIG))
            })

            return reactiveArray(value, structuredClone(REACTIVE_VARIABLE_ARRAY_CONFIG))
        }

        return reactiveVariable(value, structuredClone(REACTIVE_VARIABLE_REF_CONFIG))
    },
    computed: (callback) => {
        return reactiveVariable(callback, structuredClone(REACTIVE_VARIABLE_COMPUTED_CONFIG))
    },
    watch: (source, callback, watchConfiguration = {}) => {
        const isSourceAReactiveVariable = source?.configuration?.isReactiveVariable
        const isSourceAFunction = typeof source === 'function'
        const isSourceAnArray = Array.isArray(source)

        if (!isSourceAReactiveVariable && !isSourceAFunction && !isSourceAnArray) return

        const { immediate = false } = watchConfiguration

        if (typeof source === 'function') {
            $VindEngine.dependencyExtractorRunning = true;

            const output = source()

            if ($VindEngine.extractedDependencies.size > 0) {
                const extractedDependencies = Array.from($VindEngine.extractedDependencies);

                if (extractedDependencies.length > 0) {
                    const [firstReferencedReference] = extractedDependencies

                    if (!firstReferencedReference) return

                    extractedDependencies.forEach((extractedDependency) => {
                        $VindEngine.watchCallbacks[extractedDependency].push(callback)
                    })
                }

                $VindEngine.extractedDependencies.clear()
            }

            $VindEngine.dependencyExtractorRunning = false;


            if (immediate) {
                callback(output, output)
            }

            return
        }

        if (isSourceAnArray) {
            // in case if watch([a, b, c...])...
        }

        if (immediate) {
            callback(source.value, source.value)
        }

        const variableReference = source.variableReference

        $VindEngine.watchCallbacks[variableReference].push(callback)
    },
}

export function compileComponent(componentFunction, componentParentNode, parentContext = {}, componentName, configuration = {}) {
    if (!componentFunction) throw new Error('Component function is not defined.')
    if (!componentParentNode) throw new Error('Component parent node is not defined.')
    if (!componentName) throw new Error('Component name is not defined.')

    componentParentNode.$VindComponent ??= {}
    componentParentNode.$VindComponent.properties ??= {}

    const upperCaseComponentName = componentName.toUpperCase()

    const lifecycleCallbacks = structuredClone(LIFECYCLE_CALLBACKS_TEMPLATE)
    const properties = componentParentNode.$VindComponent.properties

    // * Defining component's destructurable properties.
    const componentInternalContext = {
        ...compilerMacros,
        onMounted: (callback) => {
            lifecycleCallbacks.onMounted = callback
        },
        onBeforeMount: (callback) => {
            lifecycleCallbacks.onBeforeMount = callback
        },
        $emit: (eventName, payload, eventInitDict = { bubbles: true }) => {
            eventInitDict.detail = payload

            const customEvent = new CustomEvent(eventName, eventInitDict)

            componentParentNode.dispatchEvent(customEvent)
        },
        $stores: $VindEngine.stores,
        $router: $VindEngine.stores.routerStore,
        $props: componentParentNode.$VindComponent.properties,
    }

    // * Binding props and transforming them into reactive variables.
    let componentProperties = $VindEngine.propertiesByComponent[componentParentNode.tagName] || [] // *  - in case the parent node's tagName is 'DIV'.

    Object.entries(componentProperties).forEach(([propertyKey, propertyConfiguration]) => {
        const kebabCasedPropertyKey = camelToKebabCase(propertyKey)

        const attributeExpression =
            componentParentNode.getAttribute(`data-vind-origin-of-${kebabCasedPropertyKey}`) ||
            componentParentNode.getAttribute(`:${kebabCasedPropertyKey}`);

        const propertyReactiveVariable = reactiveVariable(undefined, structuredClone(REACTIVE_VARIABLE_PROP_CONFIG))

        properties[propertyKey] = propertyReactiveVariable

        $VindEngine.queueReactiveEffect({
            effect: () => {
                const evaluatedJSExpression = evaluateJSExpression(parentContext, attributeExpression)

                if (evaluatedJSExpression === null && (propertyConfiguration.required || typeof propertyConfiguration.required === 'undefined')) {
                    console.warn(`Property "${propertyKey}" of component "${componentName}" is required but is either unused or null.`)
                }

                if (evaluatedJSExpression !== null && typeof evaluatedJSExpression !== propertyConfiguration.type) {
                    console.warn(`Type of passed "${propertyKey}" property does not match the type defined in its configuration. Expetected "${propertyConfiguration.type}" but got "${typeof evaluatedJSExpression}" instead.`)
                }

                propertyReactiveVariable.value = evaluatedJSExpression || (propertyConfiguration?.default || evaluatedJSExpression);
            }
        })

        if ('default' in propertyConfiguration) {
            delete propertyConfiguration.default
        }
    })

    // * Calling a component function with the context methods. The component function returns a context object.
    // * It is fine to think of it as Vue's onCreated lifecycle hook.
    const stringifiedComponentFunction = componentFunction.toString()

    const evaluatedComponentFunction = evaluateJSExpression(componentInternalContext, stringifiedComponentFunction)

    const componentContext = Object.assign(properties, evaluatedComponentFunction())

    // * Setting properties on componentContext that can be later referenced in templates by preprending them with '$' sign.
    componentContext.$path = $VindEngine.stores.routerStore.path
    componentContext.$emit = (eventName) => () => componentInternalContext.$emit(eventName)

    // * Setting componentParentNode's innerHTML to the component's template and removing the 'template' property.
    const componentTemplate = $VindEngine.templateByComponent[upperCaseComponentName] || ''

    // * Invoking onBeforeMount lifecycle hook if defined.
    lifecycleCallbacks.onBeforeMount?.()

    // * ! After running this instruction component gets its HTML content set.
    componentParentNode.innerHTML = replaceInterpolationMarkers(componentTemplate)

    const componentStyle = $VindEngine.styleByComponent[upperCaseComponentName] || ''

    // * Grabbing all inner elements of the componentParentNode that has just been created by innerHTML property.
    const componentNodeInnerElements = [...componentParentNode.querySelectorAll('*:not([data-vind-compiled-component])')]

    // * Formatting every inner node in order for easier manipulation.
    let mappedInnerNodes = componentNodeInnerElements.map((element) => {
        const attributes = [...element.attributes]

        return {
            element,
            attributes: getTranslatedAttributeNames(attributes)
        }
    })

    // * This is so-called "loop-marking". It is used to distinguish looped elements from the rest.
    // * This because loops are mounted separately from the rest of the component.
    const loopNodes = [...componentParentNode.querySelectorAll('Loop')]

    loopNodes.forEach(element => {
        const loopBlockElements = [...element.querySelectorAll('*')]

        loopBlockElements.forEach((loopBlockElement) => {
            loopBlockElement.setAttribute('data-vind-looped-element', true)
        })
    })

    // * Determining component drawers.
    const drawerNodes = [...componentParentNode.querySelectorAll('Drawer')]
    const mappedInnerDrawerTags = drawerNodes.map(drawerNode => {
        const drawerName = drawerNode.getAttribute("name")

        const targetInsertTag = componentParentNode.$VindComponent.mappedInnerInsertTags.find(insertTag => insertTag.name === drawerName)

        if (targetInsertTag) {
            drawerNode.prepend(targetInsertTag.insertNode)
        }

        return {
            element: drawerNode,
            name: drawerNode.getAttribute("name")
        }
    })

    componentParentNode.$VindComponent.mappedInnerDrawerTags = mappedInnerDrawerTags

    const componentNamesUsed = new Set()

    // * The famous "mounting" step. This is where the magic happens.
    mappedInnerNodes.forEach((mappedInnerNode) => {
        const element = mappedInnerNode.element

        const componentModule = $VindEngine.componentModules[element.tagName]

        // * insertTags
        if (componentModule) {
            componentNamesUsed.add(element.tagName)

            element.$VindComponent = {}

            const insertTags = [...element.querySelectorAll('Insert')]
            const mappedInnerInsertTags = insertTags.map(insertNode => {
                return {
                    componentNode: element,
                    insertNode,
                    name: insertNode.getAttribute("name")
                }
            })

            element.$VindComponent.mappedInnerInsertTags = mappedInnerInsertTags
        }

        // * eventAttributes
        // * Mounting event attributes that start with '@' character.
        mappedInnerNode.attributes.eventAttributes.forEach(({ name: eventBindingAttribute, value }) => {
            const evaluatedCallaback = (event) => evaluateJSExpression(componentContext, value)?.(event)

            element.addEventListener(translateEventAttribute(eventBindingAttribute), evaluatedCallaback)
        })

        // * bindingAttributes
        // * Mounting binding attributes that start with ':' character.
        mappedInnerNode.attributes.bindingAttributes.forEach(({ name: bindingAttribute, value }) => {
            const translatedBindingAttribute = translateBindingAttribute(bindingAttribute)

            element.setAttribute(`data-vind-origin-of-${translatedBindingAttribute}`, value)

            // * Note: for loop is mounted separately from other elements and has its own mounting (copied) step.
            if (bindingAttribute === ':for') {
                bindForDirective(mappedInnerNode, componentContext, componentName)

                return
            }

            const isNodeNotAChildOfLoopElement = !element.getAttribute('data-vind-looped-element')

            // * Mounting :if directive.
            if (isNodeNotAChildOfLoopElement) {
                if (bindingAttribute === ':if') {
                    bindIfDirective(element, componentContext)

                    return
                }

                // * Mounting input elements' value and checked attributes.
                const isNodeAnInputElement = element.tagName === 'INPUT'

                const inputType = element.getAttribute('type') || 'text'

                if (isNodeAnInputElement && bindingAttribute === ':model') {

                    const isStandardInputType = STANDARD_INPUT_TYPES.includes(inputType)

                    const isInputTypeWithCheckedAttribute = INPUT_TYPES_WITH_CHECKED_ATTRIBUTE.includes(inputType)

                    if (value) {
                        let proxy = undefined;

                        const isModelAttributeNested = value.includes('.')

                        if (isModelAttributeNested) {
                            const objectTokens = value.split('.')

                            const lastProperty = objectTokens.at(-1)

                            const modelObject = objectTokens.slice(0, -1).join('.')

                            proxy = evaluateJSExpression(componentContext, modelObject)

                            if (isStandardInputType) {
                                element.addEventListener('input', (event) => {
                                    proxy[lastProperty] = event.target.value
                                })
                            }

                            else if (isInputTypeWithCheckedAttribute) {
                                element.addEventListener('input', (event) => {
                                    proxy[lastProperty] = event.target.checked
                                })
                            }
                        }

                        if (!isModelAttributeNested) {
                            proxy = evaluateJSExpression(componentContext, value)

                            if (isStandardInputType) {
                                element.addEventListener('input', (event) => {
                                    proxy.value = event.target.value
                                })
                            }

                            else if (isInputTypeWithCheckedAttribute) {
                                element.addEventListener('input', (event) => {
                                    proxy.value = event.target.checked
                                })
                            }
                        }

                        let expression = isModelAttributeNested ? value : `${value}.value`

                        if (isStandardInputType) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const evaluatedExpression = evaluateJSExpression(componentContext, expression);

                                    element.setAttribute('value', evaluatedExpression);

                                    element.value = evaluatedExpression;
                                }
                            });

                            return
                        }

                        if (isInputTypeWithCheckedAttribute) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const condition = evaluateJSExpression(componentContext, expression)

                                    if (condition) {
                                        element.setAttribute('checked', condition);
                                    } else {
                                        element.removeAttribute('checked');
                                    }

                                    element.checked = condition;
                                }
                            });

                            return
                        }
                    }
                }

                if (isNodeAnInputElement && bindingAttribute === ':value') {
                    if (STANDARD_INPUT_TYPES.includes(inputType)) {
                        $VindEngine.queueReactiveEffect({
                            effect: () => {
                                const evaluatedExpression = evaluateJSExpression(componentContext, value);

                                element.setAttribute('value', evaluatedExpression);

                                element.value = evaluatedExpression;
                            }
                        });

                        return
                    }
                }

                if (isNodeAnInputElement && bindingAttribute === ':checked') {
                    if (INPUT_TYPES_WITH_CHECKED_ATTRIBUTE.includes(inputType)) {
                        $VindEngine.queueReactiveEffect({
                            effect: () => {
                                const condition = evaluateJSExpression(componentContext, value);

                                if (condition) {
                                    element.setAttribute('checked', condition);
                                } else {
                                    element.removeAttribute('checked');
                                }

                                element.checked = condition;
                            }
                        });

                        return
                    }
                }

                // * Mounting any other attribute that is not a directive.
                $VindEngine.queueReactiveEffect({
                    effect: () => {
                        const evaluatedExpression = evaluateJSExpression(componentContext, value)

                        element.setAttribute(translatedBindingAttribute, evaluatedExpression)
                    }
                })
            }
        })
    })

    // * This is used to bind reactive variables to the DOM that are not part of a loop and evaluate expressions inside {{ }} delimiters
    let interpolationNodes = undefined;

    const { target } = configuration

    if (typeof target === 'undefined' || target === 'general') {
        interpolationNodes = [...componentParentNode.querySelectorAll('vind-expression')].filter(element => !element.closest('Loop'))
    }

    else if (target === 'loop') {
        interpolationNodes = [...componentParentNode.querySelectorAll('vind-expression')]
    }


    interpolationNodes.forEach(interpolationNode => {
        const expression = interpolationNode['data-vind-expression'] ??= interpolationNode.textContent

        const textNode = document.createTextNode('')

        interpolationNode.parentNode.insertBefore(textNode, interpolationNode)
        interpolationNode.parentNode.removeChild(interpolationNode)

        $VindEngine.queueReactiveEffect({
            effect: () => {
                textNode.textContent = evaluateJSExpression(componentContext, expression)
            }
        })
    })

    // * Calling the onMounted lifecycle callback if it exists

    if (!$VindEngine.componentsWithStyleMounted.has(upperCaseComponentName)) {
        mountStyling(componentStyle, upperCaseComponentName)

        $VindEngine.componentsWithStyleMounted.add(upperCaseComponentName)
    }

    lifecycleCallbacks.onMounted?.()

    return { componentNodeReference: componentParentNode, componentNamesUsed, nextParentContext: componentContext }
}

export function templateCompiler(
    componentFunction,
    lookUpNode,
    parentContext,
    parentComponentName,
    configuration = {}
) {
    let componentElements = []
    let foundNodes = []

    const { defaultEntryPointId, target = 'general' } = configuration

    if (defaultEntryPointId) {
        foundNodes = lookUpNode.querySelectorAll(defaultEntryPointId)

        delete configuration.defaultEntryPointId
    }

    else if (parentComponentName) {
        foundNodes = lookUpNode.querySelectorAll(`${parentComponentName}:not([data-vind-compiled-component])`)
    }

    else {
        throw new Error('Parent component name is required.')
    }

    componentElements = Array.from(foundNodes)

    componentElements.forEach((componentNode) => {
        const {
            componentNodeReference,
            componentNamesUsed,
            nextParentContext
        } = compileComponent(componentFunction, componentNode, parentContext, parentComponentName, { target })

        if (componentNamesUsed.has(parentComponentName)) {
            throw new Error(`Component "${parentComponentName}" is referenced inside its body.`)
        }

        componentNode.setAttribute('data-vind-compiled-component', true)

        componentNode.prepend(...componentNodeReference.childNodes)

        const uniqueComponentNamesUsed = Array.from(componentNamesUsed)

        uniqueComponentNamesUsed.forEach(usedComponentName => {
            const componentModule = $VindEngine.componentModules[usedComponentName]

            const { componentFunction, componentName: nextComponentName } = componentModule

            templateCompiler(componentFunction, componentNode, nextParentContext, nextComponentName, configuration)
        })
    })
}