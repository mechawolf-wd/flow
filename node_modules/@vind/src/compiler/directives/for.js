import { extractLoopDescriptors } from '../../../utils/extractLoopDescriptors.js'
import { evaluateJSExpression } from '../../../utils/evaluateJSExpression.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../../../utils/getTranslatedAttributeNames.js'
import { bindIfDirective } from './if.js'

export const bindForDirective = (mappedInnerLoopNode, componentContext) => {
    // Extracting the :for attribute content, eg. item in items.
    const loopAttributeContent = mappedInnerLoopNode.element.getAttribute('data-flow-attribute-original-content-for')

    // Extracting the array and item name from the :for attribute and array's expression, eg. { arrayExpression: items, itemName: item }.
    const loopDescriptors = extractLoopDescriptors(loopAttributeContent)

    // Evaluating the array that will be looped, eg. items.
    const evaluatedTargetArray = evaluateJSExpression(componentContext, loopDescriptors.arrayExpression)

    // Extracting the HTML template of the looped element, eg. <div>{{ item }}</div>.
    const loopHTMLItemTemplate = mappedInnerLoopNode.element.innerHTML

    const effect = () => {
        // Resetting the innerHTML of the looped element.
        mappedInnerLoopNode.element.innerHTML = ''

        // Looping through the array and creating a new element for each item.
        evaluatedTargetArray.forEach((arrayElement) => {
            const currentLoopedElement = document.createElement('looped-element')

            currentLoopedElement.innerHTML = loopHTMLItemTemplate

            const loopedElementInnerNodes = [...currentLoopedElement.querySelectorAll('*')]

            let mappedInnerLoopElements = loopedElementInnerNodes.map((innerNode) => {
                const attributes = [...innerNode.attributes]

                if (attributes.length === 0) return

                return {
                    element: innerNode,
                    attributes: getTranslatedAttributeNames(attributes)
                }
            })

            mappedInnerLoopElements = mappedInnerLoopElements.filter(Boolean)

            const loopedElementContext = { ...componentContext, [loopDescriptors.itemName]: arrayElement }

            mappedInnerLoopElements.forEach(loopNode => {
                loopNode.attributes.eventAttributes.forEach(({ name: bindingAttribute, value }) => {
                    const evaluatedCallaback = evaluateJSExpression(loopedElementContext, value)

                    loopNode.element.addEventListener(translateEventAttribute(bindingAttribute), evaluatedCallaback)
                })

                loopNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
                    if (attribute === ':if') {
                        loopNode.element.setAttribute('data-flow-attribute-original-content-if', value)

                        bindIfDirective(loopNode, loopedElementContext)

                        return
                    }

                    const isNodeATextInput = attribute === ':value' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'text' || !loopNode.element.hasAttribute('type'))

                    if (isNodeATextInput) {
                        $VindEngine.queueReactiveEffect({
                            effect: () => {
                                loopNode.element.value = evaluateJSExpression(loopedElementContext, value)
                            }
                        })

                        return
                    }

                    const isNodeACheckboxInput = attribute === ':checked' && loopNode.element.tagName === 'INPUT' && (loopNode.element.getAttribute('type') === 'checkbox')

                    if (isNodeACheckboxInput) {
                        $VindEngine.queueReactiveEffect({
                            effect: () => {
                                const condition = evaluateJSExpression(loopedElementContext, value)

                                if (condition) {
                                    loopNode.element.setAttribute('checked', condition)
                                } else {
                                    loopNode.element.removeAttribute('checked')
                                }
                            }
                        })

                        return
                    }

                    $VindEngine.queueReactiveEffect({
                        effect: () => {
                            loopNode.element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(loopedElementContext, value))
                        }
                    })
                })
            })

            const interpolationNodes = [...currentLoopedElement.querySelectorAll('vind-expression')]

            interpolationNodes.forEach(interpolationNode => {
                const expression = interpolationNode['data-vind-expression'] ??= interpolationNode.textContent

                const textNode = document.createTextNode('')

                interpolationNode.parentNode.insertBefore(textNode, interpolationNode)
                interpolationNode.parentNode.removeChild(interpolationNode)

                const effect = () => {
                    textNode.textContent = evaluateJSExpression(loopedElementContext, expression)
                }

                $VindEngine.queueReactiveEffect({
                    effect
                })
            })

            mappedInnerLoopNode.element.append(...currentLoopedElement.childNodes)
        })
    }

    $VindEngine.queueReactiveEffect({
        effect
    })
}
