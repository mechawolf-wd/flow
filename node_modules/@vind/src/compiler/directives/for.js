import { extractLoopDescriptors } from '../../../utils/extractLoopDescriptors.js'
import { replaceInterpolationMarkers } from '../../../utils/formatTemplate.js'
import { evaluateJSExpression } from '../../../utils/evaluateJSExpression.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../../../utils/getTranslatedAttributeNames.js'
import { bindIfDirective } from './if.js'
import { templateCompiler } from '../templateCompiler.js'
import {
    STANDARD_INPUT_TYPES,
    INPUT_TYPES_WITH_CHECKED_ATTRIBUTE
} from '../../../configuration/configuration.js'

export const bindForDirective = (mappedInnerLoopNode, componentContext) => {
    // Extracting the :for attribute content, eg. item in items.
    const loopAttributeContent = mappedInnerLoopNode.element.getAttribute('data-vind-origin-of-for')

    // Extracting the array and item name from the :for attribute and array's expression, eg. { arrayExpression: items, itemName: item }.
    const loopDescriptors = extractLoopDescriptors(loopAttributeContent)

    // Evaluating the array that will be looped, eg. items.
    let evaluatedTargetArray = evaluateJSExpression(componentContext, loopDescriptors.arrayExpression)

    // Extracting the HTML template of the looped element, eg. <div>{{ item }}</div>.
    const loopHTMLItemTemplate = mappedInnerLoopNode.element.innerHTML

    let usedComponentNames = new Set()

    mappedInnerLoopNode.element.$VindCompnent = {}

    mappedInnerLoopNode.element.$VindCompnent.loopHTMLItemTemplate = loopHTMLItemTemplate

    const [arrayReference] = Object.entries($VindEngine.reactiveVariables).find(([key, value]) => value.variableProxy === evaluatedTargetArray)

    const mountElement = (arrayElement, componentContext, parentLoopElement) => {
        const loopHTMLItemTemplate = parentLoopElement.$VindCompnent.loopHTMLItemTemplate

        const currentLoopedElement = document.createElement('looped-element')

        currentLoopedElement.innerHTML = loopHTMLItemTemplate

        const loopedElementInnerNodes = [...currentLoopedElement.querySelectorAll('*')]

        let mappedInnerLoopElements = loopedElementInnerNodes.map((innerNode) => {
            const attributes = [...innerNode.attributes]

            if (attributes.length === 0) return

            return {
                element: innerNode,
                attributes: getTranslatedAttributeNames(attributes)
            }
        })

        mappedInnerLoopElements = mappedInnerLoopElements.filter(Boolean)

        const loopedElementContext = { ...componentContext, [loopDescriptors.itemName]: arrayElement }

        mappedInnerLoopElements.forEach(loopChildNode => {
            const element = loopChildNode.element

            const componentModule = $VindEngine.componentModules[element.tagName]

            if (componentModule) {
                usedComponentNames.add(element.tagName)
            }

            loopChildNode.attributes.eventAttributes.forEach(({ name: eventBindingAttribute, value: attributeValue }) => {
                const evaluatedCallaback = (event) => evaluateJSExpression(loopedElementContext, attributeValue)?.(event)

                element.addEventListener(translateEventAttribute(eventBindingAttribute), evaluatedCallaback)
            })

            loopChildNode.attributes.bindingAttributes.forEach(({ name: bindingAttribute, value: attributeValue }) => {
                if (bindingAttribute === ':if') {
                    element.setAttribute('data-vind-origin-of-if', attributeValue)

                    bindIfDirective(loopChildNode.element, loopedElementContext)

                    return
                }

                const isNodeAnInputElement = element.tagName === 'INPUT'

                const inputType = element.getAttribute('type') || 'text'

                if (isNodeAnInputElement && bindingAttribute === ':model') {
                    const isStandardInputType = STANDARD_INPUT_TYPES.includes(inputType)

                    const isInputTypeWithCheckedAttribute = INPUT_TYPES_WITH_CHECKED_ATTRIBUTE.includes(inputType)

                    if (attributeValue) {
                        let proxy = undefined;

                        const isModelAttributeNested = attributeValue.includes('.')

                        if (isModelAttributeNested) {
                            const objectTokens = attributeValue.split('.')

                            const lastProperty = objectTokens.at(-1)

                            const modelObject = objectTokens.slice(0, -1).join('.')

                            proxy = evaluateJSExpression(loopedElementContext, modelObject)

                            if (isStandardInputType) {
                                element.addEventListener('input', (event) => {
                                    proxy[lastProperty] = event.target.value
                                })
                            }

                            else if (isInputTypeWithCheckedAttribute) {
                                element.addEventListener('input', (event) => {
                                    proxy[lastProperty] = event.target.checked
                                })
                            }
                        }

                        if (!isModelAttributeNested) {
                            proxy = evaluateJSExpression(loopedElementContext, attributeValue)

                            if (isStandardInputType) {
                                element.addEventListener('input', (event) => {
                                    proxy.value = event.target.value
                                })
                            }

                            else if (isInputTypeWithCheckedAttribute) {
                                element.addEventListener('input', (event) => {
                                    proxy.value = event.target.checked
                                })
                            }
                        }

                        let expression = isModelAttributeNested ? attributeValue : `${attributeValue}.value`

                        if (isStandardInputType) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const evaluatedExpression = evaluateJSExpression(loopedElementContext, expression);

                                    element.setAttribute('value', evaluatedExpression);

                                    element.value = evaluatedExpression;
                                }
                            });

                            return
                        }

                        if (isInputTypeWithCheckedAttribute) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const condition = evaluateJSExpression(loopedElementContext, expression)

                                    if (condition) {
                                        element.setAttribute('checked', condition);
                                    } else {
                                        element.removeAttribute('checked');
                                    }

                                    element.checked = condition;
                                }
                            });

                            return
                        }
                    }
                }

                if (isNodeAnInputElement && bindingAttribute === ':value') {
                    if (STANDARD_INPUT_TYPES.includes(inputType)) {
                        $VindEngine.queueReactiveEffect({
                            effect: () => {
                                const evaluatedExpression = evaluateJSExpression(loopedElementContext, attributeValue);

                                element.setAttribute('value', evaluatedExpression);

                                element.value = evaluatedExpression;
                            }
                        });

                        return
                    }
                }

                if (isNodeAnInputElement && bindingAttribute === ':checked') {
                    if (INPUT_TYPES_WITH_CHECKED_ATTRIBUTE.includes(inputType)) {
                        $VindEngine.queueReactiveEffect({
                            effect: () => {
                                const condition = evaluateJSExpression(loopedElementContext, attributeValue);

                                if (condition) {
                                    element.setAttribute('checked', condition);
                                } else {
                                    element.removeAttribute('checked');
                                }

                                element.checked = condition;
                            }
                        });

                        return
                    }
                }

                $VindEngine.queueReactiveEffect({
                    effect: () => {
                        element.setAttribute(translateBindingAttribute(bindingAttribute), evaluateJSExpression(loopedElementContext, attributeValue))
                    }
                })
            })
        })

        const interpolationNodes = [...currentLoopedElement.querySelectorAll('vind-expression')]

        interpolationNodes.forEach(interpolationNode => {
            const expression = interpolationNode['data-vind-expression'] ??= interpolationNode.textContent

            const textNode = document.createTextNode('')

            interpolationNode.parentNode.insertBefore(textNode, interpolationNode)
            interpolationNode.parentNode.removeChild(interpolationNode)

            $VindEngine.queueReactiveEffect({
                effect: () => {
                    textNode.textContent = evaluateJSExpression(loopedElementContext, expression)
                }
            })
        })

        const uniqueComponentNamesUsed = Array.from(usedComponentNames)

        uniqueComponentNamesUsed.forEach((componentName) => {
            const { componentFunction } = $VindEngine.componentModules[componentName]

            templateCompiler(componentFunction, mappedInnerLoopNode.element, loopedElementContext, componentName, { target: 'loop' })
        })

        return currentLoopedElement.children
    }

    const effect = () => {
        mappedInnerLoopNode.element.innerHTML = ''

        evaluatedTargetArray.forEach(arrayElement => {
            const children = mountElement(arrayElement, componentContext, mappedInnerLoopNode.element)

            mappedInnerLoopNode.element.append(...children)
        })
    }

    $VindEngine.reactiveArraysDOMElements[arrayReference].push({
        HTMLCollection: mappedInnerLoopNode.element.children,
        parentLoopElement: mappedInnerLoopNode.element,
        componentContext,
        mountElement,
    })

    $VindEngine.queueReactiveEffect({ effect }, { predefinedReferences: [arrayReference] })
}
