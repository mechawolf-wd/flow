import { extractLoopDescriptors } from '../../../utils/extractLoopDescriptors.js'
import { evaluateJSExpression } from '../../../utils/evaluateJSExpression.js'
import { getTranslatedAttributeNames, translateBindingAttribute, translateEventAttribute } from '../../../utils/getTranslatedAttributeNames.js'
import { bindIfDirective } from './if.js'

const standardInputTypes = [
    'text',
    'number',
    'password',
    'email',
    'url',
    'tel',
    'date',
    'time',
    'color',
    'range'
];

const inputTypesWithCheckedAttribute = [
    'checkbox',
    'radio'
];

export const bindForDirective = (mappedInnerLoopNode, componentContext, componentName) => {
    // Extracting the :for attribute content, eg. item in items.
    const loopAttributeContent = mappedInnerLoopNode.element.getAttribute('data-flow-attribute-original-content-for')

    // Extracting the array and item name from the :for attribute and array's expression, eg. { arrayExpression: items, itemName: item }.
    const loopDescriptors = extractLoopDescriptors(loopAttributeContent)

    // Evaluating the array that will be looped, eg. items.
    const evaluatedTargetArray = evaluateJSExpression(componentContext, loopDescriptors.arrayExpression)

    // Extracting the HTML template of the looped element, eg. <div>{{ item }}</div>.
    const loopHTMLItemTemplate = mappedInnerLoopNode.element.innerHTML

    const effect = () => {
        // Resetting the innerHTML of the looped element.
        mappedInnerLoopNode.element.innerHTML = ''

        // Looping through the array and creating a new element for each item.
        evaluatedTargetArray.forEach((arrayElement) => {
            const currentLoopedElement = document.createElement('looped-element')

            currentLoopedElement.innerHTML = loopHTMLItemTemplate

            const loopedElementInnerNodes = [...currentLoopedElement.querySelectorAll('*')]

            let mappedInnerLoopElements = loopedElementInnerNodes.map((innerNode) => {
                const attributes = [...innerNode.attributes]

                if (attributes.length === 0) return

                return {
                    element: innerNode,
                    attributes: getTranslatedAttributeNames(attributes)
                }
            })

            mappedInnerLoopElements = mappedInnerLoopElements.filter(Boolean)

            const loopedElementContext = { ...componentContext, [loopDescriptors.itemName]: arrayElement }

            mappedInnerLoopElements.forEach(loopNode => {
                const element = loopNode.element

                loopNode.attributes.eventAttributes.forEach(({ name: bindingAttribute, value }) => {
                    const evaluatedCallaback = (event) => evaluateJSExpression(loopedElementContext, value)?.(event)

                    element.addEventListener(translateEventAttribute(bindingAttribute), evaluatedCallaback)
                })

                loopNode.attributes.bindingAttributes.forEach(({ name: attribute, value }) => {
                    if (attribute === ':if') {
                        element.setAttribute('data-flow-attribute-original-content-if', value)

                        bindIfDirective(loopNode.element, loopedElementContext)

                        return
                    }

                    const isNodeAnInput = element.tagName === 'INPUT'

                    if (isNodeAnInput) {
                        const inputType = element.getAttribute('type') || 'text'

                        const modelAttributeValue = element.getAttribute(':model')

                        if (modelAttributeValue) {
                            const proxy = componentContext[modelAttributeValue]

                            if (proxy) {
                                if (standardInputTypes.includes(inputType)) {
                                    element.addEventListener('input', (event) => {
                                        proxy.value = event.target.value
                                    })
                                } else if (inputTypesWithCheckedAttribute.includes(inputType)) {
                                    element.addEventListener('input', (event) => {
                                        proxy.value = event.target.checked
                                    })
                                }

                                if (standardInputTypes.includes(inputType)) {
                                    $VindEngine.queueReactiveEffect({
                                        effect: () => {
                                            const evaluatedExpression = evaluateJSExpression(componentContext, `${value}.value`);

                                            element.setAttribute('value', evaluatedExpression);

                                            element.value = evaluatedExpression;
                                        }
                                    });

                                    return
                                }

                                if (inputTypesWithCheckedAttribute.includes(inputType)) {
                                    $VindEngine.queueReactiveEffect({
                                        effect: () => {
                                            const condition = Boolean(evaluateJSExpression(componentContext, `${value}.value`));

                                            if (condition) {
                                                element.setAttribute('checked', true);
                                            } else {
                                                element.removeAttribute('checked');
                                            }

                                            element.checked = condition;
                                        }
                                    });

                                    return
                                }
                            } else {
                                console.error(`Reactive variable "${modelAttributeValue}" is not defined in the "${componentName}" component context.`)
                            }

                            return
                        }

                        if (inputTypesWithCheckedAttribute.includes(inputType)) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const condition = Boolean(evaluateJSExpression(componentContext, value));

                                    if (condition) {
                                        element.setAttribute('checked', true);
                                    } else {
                                        element.removeAttribute('checked');
                                    }

                                    element.checked = condition;
                                }
                            });

                            return
                        }

                        if (standardInputTypes.includes(inputType)) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const evaluatedExpression = evaluateJSExpression(componentContext, value);

                                    element.setAttribute('value', evaluatedExpression);

                                    element.value = evaluatedExpression;
                                }
                            });

                            return
                        }
                    }

                    $VindEngine.queueReactiveEffect({
                        effect: () => {
                            element.setAttribute(translateBindingAttribute(attribute), evaluateJSExpression(loopedElementContext, value))
                        }
                    })
                })
            })

            const interpolationNodes = [...currentLoopedElement.querySelectorAll('vind-expression')]

            interpolationNodes.forEach(interpolationNode => {
                const expression = interpolationNode['data-vind-expression'] ??= interpolationNode.textContent

                const textNode = document.createTextNode('')

                interpolationNode.parentNode.insertBefore(textNode, interpolationNode)
                interpolationNode.parentNode.removeChild(interpolationNode)

                $VindEngine.queueReactiveEffect({
                    effect: () => {
                        textNode.textContent = evaluateJSExpression(loopedElementContext, expression)
                    }
                })
            })

            mappedInnerLoopNode.element.append(...currentLoopedElement.childNodes)
        })
    }

    $VindEngine.queueReactiveEffect({ effect })
}
