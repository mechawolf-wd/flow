import { extractLoopDescriptors } from "../../../utils/extractLoopDescriptors.js";
import { evaluateJSExpression } from "../../../utils/evaluateJSExpression.js";
import {
    getTranslatedAttributeNames,
    translateBindingAttribute,
    translateEventAttribute,
} from "../../../utils/getTranslatedAttributeNames.js";
import { bindIfDirective } from "./if.js";
import { bindClassDirective } from "./class.js";
import { templateCompiler } from "../templateCompiler.js";
import {
    STANDARD_INPUT_TYPES,
    INPUT_TYPES_WITH_CHECKED_ATTRIBUTE,
} from "../../../configuration/configuration.js";

export const bindForDirective = (mappedLoopElement, elementContext) => {
    // Getting :for attribute's content.
    const loopAttributeContent = mappedLoopElement.element.getAttribute(":for");

    // Extracting the array and item name from the :for attribute and array's expression, eg. { arrayExpression: items, itemName: item }.
    const loopDescriptors = extractLoopDescriptors(loopAttributeContent);

    // Evaluating the array that will be looped, eg. items.
    let evaluatedTargetArray = evaluateJSExpression(
        elementContext,
        loopDescriptors.arrayExpression
    );

    if (!evaluatedTargetArray) {
        mappedLoopElement.element.innerHTML = "";
        return;
    }

    // Extracting the HTML template of the looped element, eg. <div>{{ item }}</div>.
    const loopHTMLItemTemplate = mappedLoopElement.element.innerHTML;

    let usedComponentNames = new Set();

    const arrayReferringObject = Object.entries($VindEngine.reactiveVariables).find(([, value]) => {
        return value.variableProxy === evaluatedTargetArray;
    })

    const [arrayReference] = arrayReferringObject || []

    const mountNewLoopElement = (arrayElement) => {
        const currentLoopedElement = document.createElement("looped-element");

        currentLoopedElement.innerHTML = loopHTMLItemTemplate;

        const loopedElementChildNodes = [
            ...currentLoopedElement.querySelectorAll("*:not(loop *)"),
        ];

        let mappedInnerLoopElements = loopedElementChildNodes.map((element) => {
            const attributes = [...element.attributes];

            if (attributes.length === 0) return {};

            return {
                element: element,
                attributes: getTranslatedAttributeNames(attributes),
            };
        });

        const loopedElementContext = {
            ...elementContext,
            [loopDescriptors.itemName]: arrayElement,
        };

        mappedInnerLoopElements.forEach((loopChildElement) => {
            if (Object.keys(loopChildElement).length === 0) return;

            const componentModule =
                $VindEngine.componentModules[loopChildElement.element.tagName];

            if (componentModule) {
                usedComponentNames.add(loopChildElement.element.tagName);
            }

            loopChildElement.attributes.eventAttributes.forEach(
                ({ name: eventBindingAttribute, value: attributeValue }) => {
                    const evaluatedCallaback = (event) => {
                        const expression = evaluateJSExpression(
                            loopedElementContext,
                            attributeValue
                        );

                        if (typeof expression === "function") {
                            return expression(event);
                        }
                    };

                    loopChildElement.element.addEventListener(
                        translateEventAttribute(eventBindingAttribute),
                        evaluatedCallaback
                    );
                }
            );

            loopChildElement.attributes.bindingAttributes.forEach(
                ({ name: bindingAttribute, value: attributeValue }) => {
                    const translatedBindingAttribute =
                        translateBindingAttribute(bindingAttribute);

                    loopChildElement.element.setAttribute(
                        `data-vind-origin-of-ba-${translatedBindingAttribute}`,
                        attributeValue
                    );

                    if (bindingAttribute === ":class") {
                        bindClassDirective(loopChildElement.element, loopedElementContext);

                        return;
                    }

                    if (bindingAttribute === ":if") {
                        bindIfDirective(loopChildElement.element, loopedElementContext);

                        return;
                    }

                    if (bindingAttribute === ":for") {
                        bindForDirective(loopChildElement, loopedElementContext);

                        return;
                    }

                    const isElementAnInputElement =
                        loopChildElement.element.tagName === "INPUT";

                    const inputType =
                        loopChildElement.element.getAttribute("type") || "text";

                    if (isElementAnInputElement && bindingAttribute === ":model") {
                        const isStandardInputType =
                            STANDARD_INPUT_TYPES.includes(inputType);
                        const isInputTypeWithCheckedAttribute =
                            INPUT_TYPES_WITH_CHECKED_ATTRIBUTE.includes(inputType);

                        if (attributeValue) {
                            let proxy = undefined;

                            const isModelAttributeNested = attributeValue.includes(".");

                            if (isModelAttributeNested) {
                                const objectTokens = attributeValue.split(".");

                                const lastProperty = objectTokens.at(-1);

                                const modelObject = objectTokens.slice(0, -1).join(".");

                                proxy = evaluateJSExpression(loopedElementContext, modelObject);

                                if (isStandardInputType) {
                                    loopChildElement.element.addEventListener(
                                        "input",
                                        (event) => {
                                            proxy[lastProperty] = event.target.value;
                                        }
                                    );
                                } else if (isInputTypeWithCheckedAttribute) {
                                    loopChildElement.element.addEventListener(
                                        "input",
                                        (event) => {
                                            proxy[lastProperty] = event.target.checked;
                                        }
                                    );
                                }
                            }

                            if (!isModelAttributeNested) {
                                proxy = evaluateJSExpression(
                                    loopedElementContext,
                                    attributeValue
                                );

                                if (isStandardInputType) {
                                    loopChildElement.element.addEventListener(
                                        "input",
                                        (event) => {
                                            proxy.value = event.target.value;
                                        }
                                    );
                                } else if (isInputTypeWithCheckedAttribute) {
                                    loopChildElement.element.addEventListener(
                                        "input",
                                        (event) => {
                                            proxy.value = event.target.checked;
                                        }
                                    );
                                }
                            }

                            let expression = isModelAttributeNested
                                ? attributeValue
                                : `${attributeValue}.value`;

                            if (isStandardInputType) {
                                $VindEngine.queueReactiveEffect({
                                    effect: () => {
                                        const evaluatedExpression = evaluateJSExpression(
                                            loopedElementContext,
                                            expression
                                        );

                                        loopChildElement.element.setAttribute(
                                            "value",
                                            evaluatedExpression
                                        );

                                        loopChildElement.element.value = evaluatedExpression;
                                    },
                                });

                                return;
                            }

                            if (isInputTypeWithCheckedAttribute) {
                                $VindEngine.queueReactiveEffect({
                                    effect: () => {
                                        const condition = evaluateJSExpression(
                                            loopedElementContext,
                                            expression
                                        );

                                        if (condition) {
                                            loopChildElement.element.setAttribute(
                                                "checked",
                                                condition
                                            );
                                        } else {
                                            loopChildElement.element.removeAttribute("checked");
                                        }

                                        loopChildElement.element.checked = condition;
                                    },
                                });

                                return;
                            }
                        }
                    }

                    if (isElementAnInputElement && bindingAttribute === ":value") {
                        if (STANDARD_INPUT_TYPES.includes(inputType)) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const evaluatedExpression = evaluateJSExpression(
                                        loopedElementContext,
                                        attributeValue
                                    );

                                    loopChildElement.element.setAttribute(
                                        "value",
                                        evaluatedExpression
                                    );

                                    loopChildElement.element.value = evaluatedExpression;
                                },
                            });

                            return;
                        }
                    }

                    if (isElementAnInputElement && bindingAttribute === ":checked") {
                        if (INPUT_TYPES_WITH_CHECKED_ATTRIBUTE.includes(inputType)) {
                            $VindEngine.queueReactiveEffect({
                                effect: () => {
                                    const condition = evaluateJSExpression(
                                        loopedElementContext,
                                        attributeValue
                                    );

                                    if (condition) {
                                        loopChildElement.element.setAttribute("checked", condition);
                                    } else {
                                        loopChildElement.element.removeAttribute("checked");
                                    }

                                    loopChildElement.element.checked = condition;
                                },
                            });

                            return;
                        }
                    }

                    $VindEngine.queueReactiveEffect({
                        effect: () => {
                            loopChildElement.element.setAttribute(
                                translateBindingAttribute(bindingAttribute),
                                evaluateJSExpression(loopedElementContext, attributeValue)
                            );
                        },
                    });
                }
            );
        });

        const interpolationElements = [
            ...currentLoopedElement.querySelectorAll("vind-expression"),
        ];

        interpolationElements.forEach((interpolationElement) => {
            const expression = interpolationElement.textContent;

            const textNode = document.createTextNode("");

            interpolationElement.parentNode.insertBefore(
                textNode,
                interpolationElement
            );
            interpolationElement.parentNode.removeChild(interpolationElement);

            $VindEngine.queueReactiveEffect({
                effect: () => {
                    textNode.textContent = evaluateJSExpression(
                        loopedElementContext,
                        expression
                    );
                },
            });
        });

        const uniqueComponentNamesUsed = Array.from(usedComponentNames);

        const loopedElement = currentLoopedElement.childNodes[0];

        uniqueComponentNamesUsed.forEach((componentName) => {
            const { componentFunction } = $VindEngine.componentModules[componentName];

            templateCompiler(
                componentFunction,
                loopedElement,
                loopedElementContext,
                componentName,
                { target: "loop" }
            );
        });

        return currentLoopedElement.childNodes;
    };

    const effect = () => {
        mappedLoopElement.element.innerHTML = "";

        evaluatedTargetArray.forEach((arrayElement) => {
            const childNodes = mountNewLoopElement(
                arrayElement,
                elementContext,
                mappedLoopElement.element
            );

            const wrapperDivElement = document.createElement("div");

            wrapperDivElement.append(...childNodes);

            mappedLoopElement.element.append(wrapperDivElement);
        });
    };

    if (arrayReference) {
        $VindEngine.reactiveArraysDOMElements[arrayReference].push({
            HTMLCollection: mappedLoopElement.element.childNodes,
            parentLoopElement: mappedLoopElement.element,
            mountNewLoopElement,
        });
    }

    $VindEngine.queueReactiveEffect({ effect });
};
